// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: metadata_bench.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_metadata_5fbench_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_metadata_5fbench_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metadata_store.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_metadata_5fbench_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_metadata_5fbench_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_metadata_5fbench_2eproto;
namespace ml_metadata {
class FillEdges;
class FillEdgesDefaultTypeInternal;
extern FillEdgesDefaultTypeInternal _FillEdges_default_instance_;
class FillNodes;
class FillNodesDefaultTypeInternal;
extern FillNodesDefaultTypeInternal _FillNodes_default_instance_;
class FillTypes;
class FillTypesDefaultTypeInternal;
extern FillTypesDefaultTypeInternal _FillTypes_default_instance_;
class InitStore;
class InitStoreDefaultTypeInternal;
extern InitStoreDefaultTypeInternal _InitStore_default_instance_;
class MLMDBenchConfig;
class MLMDBenchConfigDefaultTypeInternal;
extern MLMDBenchConfigDefaultTypeInternal _MLMDBenchConfig_default_instance_;
class MLMDBenchReport;
class MLMDBenchReportDefaultTypeInternal;
extern MLMDBenchReportDefaultTypeInternal _MLMDBenchReport_default_instance_;
class NormalDistribution;
class NormalDistributionDefaultTypeInternal;
extern NormalDistributionDefaultTypeInternal _NormalDistribution_default_instance_;
class ReadEdges;
class ReadEdgesDefaultTypeInternal;
extern ReadEdgesDefaultTypeInternal _ReadEdges_default_instance_;
class ReadNodes;
class ReadNodesDefaultTypeInternal;
extern ReadNodesDefaultTypeInternal _ReadNodes_default_instance_;
class ReadTypes;
class ReadTypesDefaultTypeInternal;
extern ReadTypesDefaultTypeInternal _ReadTypes_default_instance_;
class ThreadEnv;
class ThreadEnvDefaultTypeInternal;
extern ThreadEnvDefaultTypeInternal _ThreadEnv_default_instance_;
class UniformDistribution;
class UniformDistributionDefaultTypeInternal;
extern UniformDistributionDefaultTypeInternal _UniformDistribution_default_instance_;
class Workload;
class WorkloadDefaultTypeInternal;
extern WorkloadDefaultTypeInternal _Workload_default_instance_;
class WorkloadResult;
class WorkloadResultDefaultTypeInternal;
extern WorkloadResultDefaultTypeInternal _WorkloadResult_default_instance_;
}  // namespace ml_metadata
PROTOBUF_NAMESPACE_OPEN
template<> ::ml_metadata::FillEdges* Arena::CreateMaybeMessage<::ml_metadata::FillEdges>(Arena*);
template<> ::ml_metadata::FillNodes* Arena::CreateMaybeMessage<::ml_metadata::FillNodes>(Arena*);
template<> ::ml_metadata::FillTypes* Arena::CreateMaybeMessage<::ml_metadata::FillTypes>(Arena*);
template<> ::ml_metadata::InitStore* Arena::CreateMaybeMessage<::ml_metadata::InitStore>(Arena*);
template<> ::ml_metadata::MLMDBenchConfig* Arena::CreateMaybeMessage<::ml_metadata::MLMDBenchConfig>(Arena*);
template<> ::ml_metadata::MLMDBenchReport* Arena::CreateMaybeMessage<::ml_metadata::MLMDBenchReport>(Arena*);
template<> ::ml_metadata::NormalDistribution* Arena::CreateMaybeMessage<::ml_metadata::NormalDistribution>(Arena*);
template<> ::ml_metadata::ReadEdges* Arena::CreateMaybeMessage<::ml_metadata::ReadEdges>(Arena*);
template<> ::ml_metadata::ReadNodes* Arena::CreateMaybeMessage<::ml_metadata::ReadNodes>(Arena*);
template<> ::ml_metadata::ReadTypes* Arena::CreateMaybeMessage<::ml_metadata::ReadTypes>(Arena*);
template<> ::ml_metadata::ThreadEnv* Arena::CreateMaybeMessage<::ml_metadata::ThreadEnv>(Arena*);
template<> ::ml_metadata::UniformDistribution* Arena::CreateMaybeMessage<::ml_metadata::UniformDistribution>(Arena*);
template<> ::ml_metadata::Workload* Arena::CreateMaybeMessage<::ml_metadata::Workload>(Arena*);
template<> ::ml_metadata::WorkloadResult* Arena::CreateMaybeMessage<::ml_metadata::WorkloadResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ml_metadata {

enum FillTypes_specification : int {
  FillTypes_specification_ArtifactType = 0,
  FillTypes_specification_ExecutionType = 1,
  FillTypes_specification_ContextType = 2
};
bool FillTypes_specification_IsValid(int value);
constexpr FillTypes_specification FillTypes_specification_specification_MIN = FillTypes_specification_ArtifactType;
constexpr FillTypes_specification FillTypes_specification_specification_MAX = FillTypes_specification_ContextType;
constexpr int FillTypes_specification_specification_ARRAYSIZE = FillTypes_specification_specification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FillTypes_specification_descriptor();
template<typename T>
inline const std::string& FillTypes_specification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FillTypes_specification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FillTypes_specification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FillTypes_specification_descriptor(), enum_t_value);
}
inline bool FillTypes_specification_Parse(
    const std::string& name, FillTypes_specification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FillTypes_specification>(
    FillTypes_specification_descriptor(), name, value);
}
enum FillNodes_specification : int {
  FillNodes_specification_Artifact = 0,
  FillNodes_specification_Execution = 1,
  FillNodes_specification_Context = 2
};
bool FillNodes_specification_IsValid(int value);
constexpr FillNodes_specification FillNodes_specification_specification_MIN = FillNodes_specification_Artifact;
constexpr FillNodes_specification FillNodes_specification_specification_MAX = FillNodes_specification_Context;
constexpr int FillNodes_specification_specification_ARRAYSIZE = FillNodes_specification_specification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FillNodes_specification_descriptor();
template<typename T>
inline const std::string& FillNodes_specification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FillNodes_specification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FillNodes_specification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FillNodes_specification_descriptor(), enum_t_value);
}
inline bool FillNodes_specification_Parse(
    const std::string& name, FillNodes_specification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FillNodes_specification>(
    FillNodes_specification_descriptor(), name, value);
}
enum FillEdges_specification : int {
  FillEdges_specification_Event = 0,
  FillEdges_specification_Attribution = 1,
  FillEdges_specification_Association = 2
};
bool FillEdges_specification_IsValid(int value);
constexpr FillEdges_specification FillEdges_specification_specification_MIN = FillEdges_specification_Event;
constexpr FillEdges_specification FillEdges_specification_specification_MAX = FillEdges_specification_Association;
constexpr int FillEdges_specification_specification_ARRAYSIZE = FillEdges_specification_specification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FillEdges_specification_descriptor();
template<typename T>
inline const std::string& FillEdges_specification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FillEdges_specification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FillEdges_specification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FillEdges_specification_descriptor(), enum_t_value);
}
inline bool FillEdges_specification_Parse(
    const std::string& name, FillEdges_specification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FillEdges_specification>(
    FillEdges_specification_descriptor(), name, value);
}
enum ReadTypes_specification : int {
  ReadTypes_specification_ArtifactTypeByID = 0,
  ReadTypes_specification_ExecutionTypeByID = 1,
  ReadTypes_specification_ContextTypeByID = 2
};
bool ReadTypes_specification_IsValid(int value);
constexpr ReadTypes_specification ReadTypes_specification_specification_MIN = ReadTypes_specification_ArtifactTypeByID;
constexpr ReadTypes_specification ReadTypes_specification_specification_MAX = ReadTypes_specification_ContextTypeByID;
constexpr int ReadTypes_specification_specification_ARRAYSIZE = ReadTypes_specification_specification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReadTypes_specification_descriptor();
template<typename T>
inline const std::string& ReadTypes_specification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReadTypes_specification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReadTypes_specification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReadTypes_specification_descriptor(), enum_t_value);
}
inline bool ReadTypes_specification_Parse(
    const std::string& name, ReadTypes_specification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReadTypes_specification>(
    ReadTypes_specification_descriptor(), name, value);
}
enum ReadNodes_specification : int {
  ReadNodes_specification_ArtifactsByID = 0,
  ReadNodes_specification_ArtifactsByType = 1,
  ReadNodes_specification_ArtifactByTypeAndName = 2,
  ReadNodes_specification_ArtifactsByURI = 3,
  ReadNodes_specification_ArtifactsByContext = 4,
  ReadNodes_specification_ExecutionsByID = 5,
  ReadNodes_specification_ExecutionsByType = 6,
  ReadNodes_specification_ExecutionByTypeAndName = 7,
  ReadNodes_specification_ExecutionsByContext = 8,
  ReadNodes_specification_ContextsByID = 9,
  ReadNodes_specification_ContextsByType = 10,
  ReadNodes_specification_ContextByTypeAndName = 11,
  ReadNodes_specification_ContextsByArtifact = 12,
  ReadNodes_specification_ContextsByExecution = 13
};
bool ReadNodes_specification_IsValid(int value);
constexpr ReadNodes_specification ReadNodes_specification_specification_MIN = ReadNodes_specification_ArtifactsByID;
constexpr ReadNodes_specification ReadNodes_specification_specification_MAX = ReadNodes_specification_ContextsByExecution;
constexpr int ReadNodes_specification_specification_ARRAYSIZE = ReadNodes_specification_specification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReadNodes_specification_descriptor();
template<typename T>
inline const std::string& ReadNodes_specification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReadNodes_specification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReadNodes_specification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReadNodes_specification_descriptor(), enum_t_value);
}
inline bool ReadNodes_specification_Parse(
    const std::string& name, ReadNodes_specification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReadNodes_specification>(
    ReadNodes_specification_descriptor(), name, value);
}
enum ReadEdges_specification : int {
  ReadEdges_specification_EventsByExecutionIDs = 0,
  ReadEdges_specification_EventsByArtifactIDs = 1
};
bool ReadEdges_specification_IsValid(int value);
constexpr ReadEdges_specification ReadEdges_specification_specification_MIN = ReadEdges_specification_EventsByExecutionIDs;
constexpr ReadEdges_specification ReadEdges_specification_specification_MAX = ReadEdges_specification_EventsByArtifactIDs;
constexpr int ReadEdges_specification_specification_ARRAYSIZE = ReadEdges_specification_specification_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReadEdges_specification_descriptor();
template<typename T>
inline const std::string& ReadEdges_specification_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReadEdges_specification>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReadEdges_specification_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReadEdges_specification_descriptor(), enum_t_value);
}
inline bool ReadEdges_specification_Parse(
    const std::string& name, ReadEdges_specification* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReadEdges_specification>(
    ReadEdges_specification_descriptor(), name, value);
}
// ===================================================================

class MLMDBenchConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MLMDBenchConfig) */ {
 public:
  inline MLMDBenchConfig() : MLMDBenchConfig(nullptr) {};
  virtual ~MLMDBenchConfig();

  MLMDBenchConfig(const MLMDBenchConfig& from);
  MLMDBenchConfig(MLMDBenchConfig&& from) noexcept
    : MLMDBenchConfig() {
    *this = ::std::move(from);
  }

  inline MLMDBenchConfig& operator=(const MLMDBenchConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLMDBenchConfig& operator=(MLMDBenchConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MLMDBenchConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLMDBenchConfig* internal_default_instance() {
    return reinterpret_cast<const MLMDBenchConfig*>(
               &_MLMDBenchConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MLMDBenchConfig& a, MLMDBenchConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MLMDBenchConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLMDBenchConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MLMDBenchConfig* New() const final {
    return CreateMaybeMessage<MLMDBenchConfig>(nullptr);
  }

  MLMDBenchConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MLMDBenchConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MLMDBenchConfig& from);
  void MergeFrom(const MLMDBenchConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLMDBenchConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MLMDBenchConfig";
  }
  protected:
  explicit MLMDBenchConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkloadsFieldNumber = 2,
    kMlmdConfigFieldNumber = 1,
    kThreadEnvFieldNumber = 3,
  };
  // repeated .ml_metadata.Workload workloads = 2;
  int workloads_size() const;
  private:
  int _internal_workloads_size() const;
  public:
  void clear_workloads();
  ::ml_metadata::Workload* mutable_workloads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Workload >*
      mutable_workloads();
  private:
  const ::ml_metadata::Workload& _internal_workloads(int index) const;
  ::ml_metadata::Workload* _internal_add_workloads();
  public:
  const ::ml_metadata::Workload& workloads(int index) const;
  ::ml_metadata::Workload* add_workloads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Workload >&
      workloads() const;

  // optional .ml_metadata.ConnectionConfig mlmd_config = 1;
  bool has_mlmd_config() const;
  private:
  bool _internal_has_mlmd_config() const;
  public:
  void clear_mlmd_config();
  const ::ml_metadata::ConnectionConfig& mlmd_config() const;
  ::ml_metadata::ConnectionConfig* release_mlmd_config();
  ::ml_metadata::ConnectionConfig* mutable_mlmd_config();
  void set_allocated_mlmd_config(::ml_metadata::ConnectionConfig* mlmd_config);
  private:
  const ::ml_metadata::ConnectionConfig& _internal_mlmd_config() const;
  ::ml_metadata::ConnectionConfig* _internal_mutable_mlmd_config();
  public:
  void unsafe_arena_set_allocated_mlmd_config(
      ::ml_metadata::ConnectionConfig* mlmd_config);
  ::ml_metadata::ConnectionConfig* unsafe_arena_release_mlmd_config();

  // optional .ml_metadata.ThreadEnv thread_env = 3;
  bool has_thread_env() const;
  private:
  bool _internal_has_thread_env() const;
  public:
  void clear_thread_env();
  const ::ml_metadata::ThreadEnv& thread_env() const;
  ::ml_metadata::ThreadEnv* release_thread_env();
  ::ml_metadata::ThreadEnv* mutable_thread_env();
  void set_allocated_thread_env(::ml_metadata::ThreadEnv* thread_env);
  private:
  const ::ml_metadata::ThreadEnv& _internal_thread_env() const;
  ::ml_metadata::ThreadEnv* _internal_mutable_thread_env();
  public:
  void unsafe_arena_set_allocated_thread_env(
      ::ml_metadata::ThreadEnv* thread_env);
  ::ml_metadata::ThreadEnv* unsafe_arena_release_thread_env();

  // @@protoc_insertion_point(class_scope:ml_metadata.MLMDBenchConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Workload > workloads_;
  ::ml_metadata::ConnectionConfig* mlmd_config_;
  ::ml_metadata::ThreadEnv* thread_env_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class UniformDistribution PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.UniformDistribution) */ {
 public:
  inline UniformDistribution() : UniformDistribution(nullptr) {};
  virtual ~UniformDistribution();

  UniformDistribution(const UniformDistribution& from);
  UniformDistribution(UniformDistribution&& from) noexcept
    : UniformDistribution() {
    *this = ::std::move(from);
  }

  inline UniformDistribution& operator=(const UniformDistribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline UniformDistribution& operator=(UniformDistribution&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UniformDistribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UniformDistribution* internal_default_instance() {
    return reinterpret_cast<const UniformDistribution*>(
               &_UniformDistribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UniformDistribution& a, UniformDistribution& b) {
    a.Swap(&b);
  }
  inline void Swap(UniformDistribution* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UniformDistribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UniformDistribution* New() const final {
    return CreateMaybeMessage<UniformDistribution>(nullptr);
  }

  UniformDistribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UniformDistribution>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UniformDistribution& from);
  void MergeFrom(const UniformDistribution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UniformDistribution* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.UniformDistribution";
  }
  protected:
  explicit UniformDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRangeBeginFieldNumber = 1,
    kRangeEndFieldNumber = 2,
  };
  // optional int32 range_begin = 1 [default = 1];
  bool has_range_begin() const;
  private:
  bool _internal_has_range_begin() const;
  public:
  void clear_range_begin();
  ::PROTOBUF_NAMESPACE_ID::int32 range_begin() const;
  void set_range_begin(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_range_begin() const;
  void _internal_set_range_begin(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 range_end = 2 [default = 10];
  bool has_range_end() const;
  private:
  bool _internal_has_range_end() const;
  public:
  void clear_range_end();
  ::PROTOBUF_NAMESPACE_ID::int32 range_end() const;
  void set_range_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_range_end() const;
  void _internal_set_range_end(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.UniformDistribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 range_begin_;
  ::PROTOBUF_NAMESPACE_ID::int32 range_end_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class NormalDistribution PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.NormalDistribution) */ {
 public:
  inline NormalDistribution() : NormalDistribution(nullptr) {};
  virtual ~NormalDistribution();

  NormalDistribution(const NormalDistribution& from);
  NormalDistribution(NormalDistribution&& from) noexcept
    : NormalDistribution() {
    *this = ::std::move(from);
  }

  inline NormalDistribution& operator=(const NormalDistribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline NormalDistribution& operator=(NormalDistribution&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NormalDistribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NormalDistribution* internal_default_instance() {
    return reinterpret_cast<const NormalDistribution*>(
               &_NormalDistribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NormalDistribution& a, NormalDistribution& b) {
    a.Swap(&b);
  }
  inline void Swap(NormalDistribution* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NormalDistribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NormalDistribution* New() const final {
    return CreateMaybeMessage<NormalDistribution>(nullptr);
  }

  NormalDistribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NormalDistribution>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NormalDistribution& from);
  void MergeFrom(const NormalDistribution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NormalDistribution* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.NormalDistribution";
  }
  protected:
  explicit NormalDistribution(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoefficientOfVariationFieldNumber = 1,
  };
  // optional int32 coefficient_of_variation = 1 [default = 5];
  bool has_coefficient_of_variation() const;
  private:
  bool _internal_has_coefficient_of_variation() const;
  public:
  void clear_coefficient_of_variation();
  ::PROTOBUF_NAMESPACE_ID::int32 coefficient_of_variation() const;
  void set_coefficient_of_variation(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_coefficient_of_variation() const;
  void _internal_set_coefficient_of_variation(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.NormalDistribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 coefficient_of_variation_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class InitStore PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.InitStore) */ {
 public:
  inline InitStore() : InitStore(nullptr) {};
  virtual ~InitStore();

  InitStore(const InitStore& from);
  InitStore(InitStore&& from) noexcept
    : InitStore() {
    *this = ::std::move(from);
  }

  inline InitStore& operator=(const InitStore& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitStore& operator=(InitStore&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InitStore& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitStore* internal_default_instance() {
    return reinterpret_cast<const InitStore*>(
               &_InitStore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InitStore& a, InitStore& b) {
    a.Swap(&b);
  }
  inline void Swap(InitStore* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitStore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InitStore* New() const final {
    return CreateMaybeMessage<InitStore>(nullptr);
  }

  InitStore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InitStore>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InitStore& from);
  void MergeFrom(const InitStore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitStore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.InitStore";
  }
  protected:
  explicit InitStore(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMlmdConfigFieldNumber = 1,
  };
  // optional .ml_metadata.ConnectionConfig mlmd_config = 1;
  bool has_mlmd_config() const;
  private:
  bool _internal_has_mlmd_config() const;
  public:
  void clear_mlmd_config();
  const ::ml_metadata::ConnectionConfig& mlmd_config() const;
  ::ml_metadata::ConnectionConfig* release_mlmd_config();
  ::ml_metadata::ConnectionConfig* mutable_mlmd_config();
  void set_allocated_mlmd_config(::ml_metadata::ConnectionConfig* mlmd_config);
  private:
  const ::ml_metadata::ConnectionConfig& _internal_mlmd_config() const;
  ::ml_metadata::ConnectionConfig* _internal_mutable_mlmd_config();
  public:
  void unsafe_arena_set_allocated_mlmd_config(
      ::ml_metadata::ConnectionConfig* mlmd_config);
  ::ml_metadata::ConnectionConfig* unsafe_arena_release_mlmd_config();

  // @@protoc_insertion_point(class_scope:ml_metadata.InitStore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::ConnectionConfig* mlmd_config_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class FillTypes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.FillTypes) */ {
 public:
  inline FillTypes() : FillTypes(nullptr) {};
  virtual ~FillTypes();

  FillTypes(const FillTypes& from);
  FillTypes(FillTypes&& from) noexcept
    : FillTypes() {
    *this = ::std::move(from);
  }

  inline FillTypes& operator=(const FillTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillTypes& operator=(FillTypes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FillTypes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FillTypes* internal_default_instance() {
    return reinterpret_cast<const FillTypes*>(
               &_FillTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FillTypes& a, FillTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(FillTypes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillTypes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FillTypes* New() const final {
    return CreateMaybeMessage<FillTypes>(nullptr);
  }

  FillTypes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FillTypes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FillTypes& from);
  void MergeFrom(const FillTypes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillTypes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.FillTypes";
  }
  protected:
  explicit FillTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FillTypes_specification specification;
  static constexpr specification ArtifactType =
    FillTypes_specification_ArtifactType;
  static constexpr specification ExecutionType =
    FillTypes_specification_ExecutionType;
  static constexpr specification ContextType =
    FillTypes_specification_ContextType;
  static inline bool specification_IsValid(int value) {
    return FillTypes_specification_IsValid(value);
  }
  static constexpr specification specification_MIN =
    FillTypes_specification_specification_MIN;
  static constexpr specification specification_MAX =
    FillTypes_specification_specification_MAX;
  static constexpr int specification_ARRAYSIZE =
    FillTypes_specification_specification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  specification_descriptor() {
    return FillTypes_specification_descriptor();
  }
  template<typename T>
  static inline const std::string& specification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, specification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function specification_Name.");
    return FillTypes_specification_Name(enum_t_value);
  }
  static inline bool specification_Parse(const std::string& name,
      specification* value) {
    return FillTypes_specification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumPropertiesFieldNumber = 2,
    kUpdateFieldNumber = 1,
  };
  // optional .ml_metadata.UniformDistribution num_properties = 2;
  bool has_num_properties() const;
  private:
  bool _internal_has_num_properties() const;
  public:
  void clear_num_properties();
  const ::ml_metadata::UniformDistribution& num_properties() const;
  ::ml_metadata::UniformDistribution* release_num_properties();
  ::ml_metadata::UniformDistribution* mutable_num_properties();
  void set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties);
  private:
  const ::ml_metadata::UniformDistribution& _internal_num_properties() const;
  ::ml_metadata::UniformDistribution* _internal_mutable_num_properties();
  public:
  void unsafe_arena_set_allocated_num_properties(
      ::ml_metadata::UniformDistribution* num_properties);
  ::ml_metadata::UniformDistribution* unsafe_arena_release_num_properties();

  // optional bool update = 1 [default = false];
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  bool update() const;
  void set_update(bool value);
  private:
  bool _internal_update() const;
  void _internal_set_update(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.FillTypes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::UniformDistribution* num_properties_;
  bool update_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class FillNodes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.FillNodes) */ {
 public:
  inline FillNodes() : FillNodes(nullptr) {};
  virtual ~FillNodes();

  FillNodes(const FillNodes& from);
  FillNodes(FillNodes&& from) noexcept
    : FillNodes() {
    *this = ::std::move(from);
  }

  inline FillNodes& operator=(const FillNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillNodes& operator=(FillNodes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FillNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FillNodes* internal_default_instance() {
    return reinterpret_cast<const FillNodes*>(
               &_FillNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FillNodes& a, FillNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(FillNodes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FillNodes* New() const final {
    return CreateMaybeMessage<FillNodes>(nullptr);
  }

  FillNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FillNodes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FillNodes& from);
  void MergeFrom(const FillNodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillNodes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.FillNodes";
  }
  protected:
  explicit FillNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FillNodes_specification specification;
  static constexpr specification Artifact =
    FillNodes_specification_Artifact;
  static constexpr specification Execution =
    FillNodes_specification_Execution;
  static constexpr specification Context =
    FillNodes_specification_Context;
  static inline bool specification_IsValid(int value) {
    return FillNodes_specification_IsValid(value);
  }
  static constexpr specification specification_MIN =
    FillNodes_specification_specification_MIN;
  static constexpr specification specification_MAX =
    FillNodes_specification_specification_MAX;
  static constexpr int specification_ARRAYSIZE =
    FillNodes_specification_specification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  specification_descriptor() {
    return FillNodes_specification_descriptor();
  }
  template<typename T>
  static inline const std::string& specification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, specification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function specification_Name.");
    return FillNodes_specification_Name(enum_t_value);
  }
  static inline bool specification_Parse(const std::string& name,
      specification* value) {
    return FillNodes_specification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumPropertiesFieldNumber = 2,
    kUpdateFieldNumber = 1,
  };
  // optional .ml_metadata.UniformDistribution num_properties = 2;
  bool has_num_properties() const;
  private:
  bool _internal_has_num_properties() const;
  public:
  void clear_num_properties();
  const ::ml_metadata::UniformDistribution& num_properties() const;
  ::ml_metadata::UniformDistribution* release_num_properties();
  ::ml_metadata::UniformDistribution* mutable_num_properties();
  void set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties);
  private:
  const ::ml_metadata::UniformDistribution& _internal_num_properties() const;
  ::ml_metadata::UniformDistribution* _internal_mutable_num_properties();
  public:
  void unsafe_arena_set_allocated_num_properties(
      ::ml_metadata::UniformDistribution* num_properties);
  ::ml_metadata::UniformDistribution* unsafe_arena_release_num_properties();

  // optional bool update = 1 [default = false];
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  bool update() const;
  void set_update(bool value);
  private:
  bool _internal_update() const;
  void _internal_set_update(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.FillNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::UniformDistribution* num_properties_;
  bool update_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class FillEdges PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.FillEdges) */ {
 public:
  inline FillEdges() : FillEdges(nullptr) {};
  virtual ~FillEdges();

  FillEdges(const FillEdges& from);
  FillEdges(FillEdges&& from) noexcept
    : FillEdges() {
    *this = ::std::move(from);
  }

  inline FillEdges& operator=(const FillEdges& from) {
    CopyFrom(from);
    return *this;
  }
  inline FillEdges& operator=(FillEdges&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FillEdges& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FillEdges* internal_default_instance() {
    return reinterpret_cast<const FillEdges*>(
               &_FillEdges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FillEdges& a, FillEdges& b) {
    a.Swap(&b);
  }
  inline void Swap(FillEdges* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FillEdges* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FillEdges* New() const final {
    return CreateMaybeMessage<FillEdges>(nullptr);
  }

  FillEdges* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FillEdges>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FillEdges& from);
  void MergeFrom(const FillEdges& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillEdges* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.FillEdges";
  }
  protected:
  explicit FillEdges(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FillEdges_specification specification;
  static constexpr specification Event =
    FillEdges_specification_Event;
  static constexpr specification Attribution =
    FillEdges_specification_Attribution;
  static constexpr specification Association =
    FillEdges_specification_Association;
  static inline bool specification_IsValid(int value) {
    return FillEdges_specification_IsValid(value);
  }
  static constexpr specification specification_MIN =
    FillEdges_specification_specification_MIN;
  static constexpr specification specification_MAX =
    FillEdges_specification_specification_MAX;
  static constexpr int specification_ARRAYSIZE =
    FillEdges_specification_specification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  specification_descriptor() {
    return FillEdges_specification_descriptor();
  }
  template<typename T>
  static inline const std::string& specification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, specification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function specification_Name.");
    return FillEdges_specification_Name(enum_t_value);
  }
  static inline bool specification_Parse(const std::string& name,
      specification* value) {
    return FillEdges_specification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBipartiteDistribution1FieldNumber = 1,
    kBipartiteDistribution2FieldNumber = 2,
  };
  // optional .ml_metadata.NormalDistribution bipartite_distribution1 = 1;
  bool has_bipartite_distribution1() const;
  private:
  bool _internal_has_bipartite_distribution1() const;
  public:
  void clear_bipartite_distribution1();
  const ::ml_metadata::NormalDistribution& bipartite_distribution1() const;
  ::ml_metadata::NormalDistribution* release_bipartite_distribution1();
  ::ml_metadata::NormalDistribution* mutable_bipartite_distribution1();
  void set_allocated_bipartite_distribution1(::ml_metadata::NormalDistribution* bipartite_distribution1);
  private:
  const ::ml_metadata::NormalDistribution& _internal_bipartite_distribution1() const;
  ::ml_metadata::NormalDistribution* _internal_mutable_bipartite_distribution1();
  public:
  void unsafe_arena_set_allocated_bipartite_distribution1(
      ::ml_metadata::NormalDistribution* bipartite_distribution1);
  ::ml_metadata::NormalDistribution* unsafe_arena_release_bipartite_distribution1();

  // optional .ml_metadata.NormalDistribution bipartite_distribution2 = 2;
  bool has_bipartite_distribution2() const;
  private:
  bool _internal_has_bipartite_distribution2() const;
  public:
  void clear_bipartite_distribution2();
  const ::ml_metadata::NormalDistribution& bipartite_distribution2() const;
  ::ml_metadata::NormalDistribution* release_bipartite_distribution2();
  ::ml_metadata::NormalDistribution* mutable_bipartite_distribution2();
  void set_allocated_bipartite_distribution2(::ml_metadata::NormalDistribution* bipartite_distribution2);
  private:
  const ::ml_metadata::NormalDistribution& _internal_bipartite_distribution2() const;
  ::ml_metadata::NormalDistribution* _internal_mutable_bipartite_distribution2();
  public:
  void unsafe_arena_set_allocated_bipartite_distribution2(
      ::ml_metadata::NormalDistribution* bipartite_distribution2);
  ::ml_metadata::NormalDistribution* unsafe_arena_release_bipartite_distribution2();

  // @@protoc_insertion_point(class_scope:ml_metadata.FillEdges)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::NormalDistribution* bipartite_distribution1_;
  ::ml_metadata::NormalDistribution* bipartite_distribution2_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class ReadTypes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ReadTypes) */ {
 public:
  inline ReadTypes() : ReadTypes(nullptr) {};
  virtual ~ReadTypes();

  ReadTypes(const ReadTypes& from);
  ReadTypes(ReadTypes&& from) noexcept
    : ReadTypes() {
    *this = ::std::move(from);
  }

  inline ReadTypes& operator=(const ReadTypes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadTypes& operator=(ReadTypes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadTypes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadTypes* internal_default_instance() {
    return reinterpret_cast<const ReadTypes*>(
               &_ReadTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReadTypes& a, ReadTypes& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadTypes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadTypes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadTypes* New() const final {
    return CreateMaybeMessage<ReadTypes>(nullptr);
  }

  ReadTypes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadTypes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadTypes& from);
  void MergeFrom(const ReadTypes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadTypes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ReadTypes";
  }
  protected:
  explicit ReadTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ReadTypes_specification specification;
  static constexpr specification ArtifactTypeByID =
    ReadTypes_specification_ArtifactTypeByID;
  static constexpr specification ExecutionTypeByID =
    ReadTypes_specification_ExecutionTypeByID;
  static constexpr specification ContextTypeByID =
    ReadTypes_specification_ContextTypeByID;
  static inline bool specification_IsValid(int value) {
    return ReadTypes_specification_IsValid(value);
  }
  static constexpr specification specification_MIN =
    ReadTypes_specification_specification_MIN;
  static constexpr specification specification_MAX =
    ReadTypes_specification_specification_MAX;
  static constexpr int specification_ARRAYSIZE =
    ReadTypes_specification_specification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  specification_descriptor() {
    return ReadTypes_specification_descriptor();
  }
  template<typename T>
  static inline const std::string& specification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, specification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function specification_Name.");
    return ReadTypes_specification_Name(enum_t_value);
  }
  static inline bool specification_Parse(const std::string& name,
      specification* value) {
    return ReadTypes_specification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumPropertiesFieldNumber = 1,
  };
  // optional .ml_metadata.UniformDistribution num_properties = 1;
  bool has_num_properties() const;
  private:
  bool _internal_has_num_properties() const;
  public:
  void clear_num_properties();
  const ::ml_metadata::UniformDistribution& num_properties() const;
  ::ml_metadata::UniformDistribution* release_num_properties();
  ::ml_metadata::UniformDistribution* mutable_num_properties();
  void set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties);
  private:
  const ::ml_metadata::UniformDistribution& _internal_num_properties() const;
  ::ml_metadata::UniformDistribution* _internal_mutable_num_properties();
  public:
  void unsafe_arena_set_allocated_num_properties(
      ::ml_metadata::UniformDistribution* num_properties);
  ::ml_metadata::UniformDistribution* unsafe_arena_release_num_properties();

  // @@protoc_insertion_point(class_scope:ml_metadata.ReadTypes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::UniformDistribution* num_properties_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class ReadNodes PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ReadNodes) */ {
 public:
  inline ReadNodes() : ReadNodes(nullptr) {};
  virtual ~ReadNodes();

  ReadNodes(const ReadNodes& from);
  ReadNodes(ReadNodes&& from) noexcept
    : ReadNodes() {
    *this = ::std::move(from);
  }

  inline ReadNodes& operator=(const ReadNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadNodes& operator=(ReadNodes&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadNodes* internal_default_instance() {
    return reinterpret_cast<const ReadNodes*>(
               &_ReadNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReadNodes& a, ReadNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadNodes* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadNodes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadNodes* New() const final {
    return CreateMaybeMessage<ReadNodes>(nullptr);
  }

  ReadNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadNodes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadNodes& from);
  void MergeFrom(const ReadNodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadNodes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ReadNodes";
  }
  protected:
  explicit ReadNodes(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ReadNodes_specification specification;
  static constexpr specification ArtifactsByID =
    ReadNodes_specification_ArtifactsByID;
  static constexpr specification ArtifactsByType =
    ReadNodes_specification_ArtifactsByType;
  static constexpr specification ArtifactByTypeAndName =
    ReadNodes_specification_ArtifactByTypeAndName;
  static constexpr specification ArtifactsByURI =
    ReadNodes_specification_ArtifactsByURI;
  static constexpr specification ArtifactsByContext =
    ReadNodes_specification_ArtifactsByContext;
  static constexpr specification ExecutionsByID =
    ReadNodes_specification_ExecutionsByID;
  static constexpr specification ExecutionsByType =
    ReadNodes_specification_ExecutionsByType;
  static constexpr specification ExecutionByTypeAndName =
    ReadNodes_specification_ExecutionByTypeAndName;
  static constexpr specification ExecutionsByContext =
    ReadNodes_specification_ExecutionsByContext;
  static constexpr specification ContextsByID =
    ReadNodes_specification_ContextsByID;
  static constexpr specification ContextsByType =
    ReadNodes_specification_ContextsByType;
  static constexpr specification ContextByTypeAndName =
    ReadNodes_specification_ContextByTypeAndName;
  static constexpr specification ContextsByArtifact =
    ReadNodes_specification_ContextsByArtifact;
  static constexpr specification ContextsByExecution =
    ReadNodes_specification_ContextsByExecution;
  static inline bool specification_IsValid(int value) {
    return ReadNodes_specification_IsValid(value);
  }
  static constexpr specification specification_MIN =
    ReadNodes_specification_specification_MIN;
  static constexpr specification specification_MAX =
    ReadNodes_specification_specification_MAX;
  static constexpr int specification_ARRAYSIZE =
    ReadNodes_specification_specification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  specification_descriptor() {
    return ReadNodes_specification_descriptor();
  }
  template<typename T>
  static inline const std::string& specification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, specification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function specification_Name.");
    return ReadNodes_specification_Name(enum_t_value);
  }
  static inline bool specification_Parse(const std::string& name,
      specification* value) {
    return ReadNodes_specification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNumPropertiesFieldNumber = 1,
  };
  // optional .ml_metadata.UniformDistribution num_properties = 1;
  bool has_num_properties() const;
  private:
  bool _internal_has_num_properties() const;
  public:
  void clear_num_properties();
  const ::ml_metadata::UniformDistribution& num_properties() const;
  ::ml_metadata::UniformDistribution* release_num_properties();
  ::ml_metadata::UniformDistribution* mutable_num_properties();
  void set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties);
  private:
  const ::ml_metadata::UniformDistribution& _internal_num_properties() const;
  ::ml_metadata::UniformDistribution* _internal_mutable_num_properties();
  public:
  void unsafe_arena_set_allocated_num_properties(
      ::ml_metadata::UniformDistribution* num_properties);
  ::ml_metadata::UniformDistribution* unsafe_arena_release_num_properties();

  // @@protoc_insertion_point(class_scope:ml_metadata.ReadNodes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::UniformDistribution* num_properties_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class ReadEdges PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ReadEdges) */ {
 public:
  inline ReadEdges() : ReadEdges(nullptr) {};
  virtual ~ReadEdges();

  ReadEdges(const ReadEdges& from);
  ReadEdges(ReadEdges&& from) noexcept
    : ReadEdges() {
    *this = ::std::move(from);
  }

  inline ReadEdges& operator=(const ReadEdges& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadEdges& operator=(ReadEdges&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReadEdges& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadEdges* internal_default_instance() {
    return reinterpret_cast<const ReadEdges*>(
               &_ReadEdges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ReadEdges& a, ReadEdges& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadEdges* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadEdges* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReadEdges* New() const final {
    return CreateMaybeMessage<ReadEdges>(nullptr);
  }

  ReadEdges* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReadEdges>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReadEdges& from);
  void MergeFrom(const ReadEdges& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadEdges* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ReadEdges";
  }
  protected:
  explicit ReadEdges(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ReadEdges_specification specification;
  static constexpr specification EventsByExecutionIDs =
    ReadEdges_specification_EventsByExecutionIDs;
  static constexpr specification EventsByArtifactIDs =
    ReadEdges_specification_EventsByArtifactIDs;
  static inline bool specification_IsValid(int value) {
    return ReadEdges_specification_IsValid(value);
  }
  static constexpr specification specification_MIN =
    ReadEdges_specification_specification_MIN;
  static constexpr specification specification_MAX =
    ReadEdges_specification_specification_MAX;
  static constexpr int specification_ARRAYSIZE =
    ReadEdges_specification_specification_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  specification_descriptor() {
    return ReadEdges_specification_descriptor();
  }
  template<typename T>
  static inline const std::string& specification_Name(T enum_t_value) {
    static_assert(::std::is_same<T, specification>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function specification_Name.");
    return ReadEdges_specification_Name(enum_t_value);
  }
  static inline bool specification_Parse(const std::string& name,
      specification* value) {
    return ReadEdges_specification_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBipartiteDistribution1FieldNumber = 1,
    kBipartiteDistribution2FieldNumber = 2,
  };
  // optional .ml_metadata.NormalDistribution bipartite_distribution1 = 1;
  bool has_bipartite_distribution1() const;
  private:
  bool _internal_has_bipartite_distribution1() const;
  public:
  void clear_bipartite_distribution1();
  const ::ml_metadata::NormalDistribution& bipartite_distribution1() const;
  ::ml_metadata::NormalDistribution* release_bipartite_distribution1();
  ::ml_metadata::NormalDistribution* mutable_bipartite_distribution1();
  void set_allocated_bipartite_distribution1(::ml_metadata::NormalDistribution* bipartite_distribution1);
  private:
  const ::ml_metadata::NormalDistribution& _internal_bipartite_distribution1() const;
  ::ml_metadata::NormalDistribution* _internal_mutable_bipartite_distribution1();
  public:
  void unsafe_arena_set_allocated_bipartite_distribution1(
      ::ml_metadata::NormalDistribution* bipartite_distribution1);
  ::ml_metadata::NormalDistribution* unsafe_arena_release_bipartite_distribution1();

  // optional .ml_metadata.NormalDistribution bipartite_distribution2 = 2;
  bool has_bipartite_distribution2() const;
  private:
  bool _internal_has_bipartite_distribution2() const;
  public:
  void clear_bipartite_distribution2();
  const ::ml_metadata::NormalDistribution& bipartite_distribution2() const;
  ::ml_metadata::NormalDistribution* release_bipartite_distribution2();
  ::ml_metadata::NormalDistribution* mutable_bipartite_distribution2();
  void set_allocated_bipartite_distribution2(::ml_metadata::NormalDistribution* bipartite_distribution2);
  private:
  const ::ml_metadata::NormalDistribution& _internal_bipartite_distribution2() const;
  ::ml_metadata::NormalDistribution* _internal_mutable_bipartite_distribution2();
  public:
  void unsafe_arena_set_allocated_bipartite_distribution2(
      ::ml_metadata::NormalDistribution* bipartite_distribution2);
  ::ml_metadata::NormalDistribution* unsafe_arena_release_bipartite_distribution2();

  // @@protoc_insertion_point(class_scope:ml_metadata.ReadEdges)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::NormalDistribution* bipartite_distribution1_;
  ::ml_metadata::NormalDistribution* bipartite_distribution2_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class Workload PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.Workload) */ {
 public:
  inline Workload() : Workload(nullptr) {};
  virtual ~Workload();

  Workload(const Workload& from);
  Workload(Workload&& from) noexcept
    : Workload() {
    *this = ::std::move(from);
  }

  inline Workload& operator=(const Workload& from) {
    CopyFrom(from);
    return *this;
  }
  inline Workload& operator=(Workload&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Workload& default_instance();

  enum WorkloadsCase {
    kInitStore = 1,
    kFillTypes = 2,
    kFillNodes = 3,
    kFillEdges = 4,
    kReadTypes = 5,
    kReadNodes = 6,
    kReadEdges = 7,
    WORKLOADS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Workload* internal_default_instance() {
    return reinterpret_cast<const Workload*>(
               &_Workload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Workload& a, Workload& b) {
    a.Swap(&b);
  }
  inline void Swap(Workload* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Workload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Workload* New() const final {
    return CreateMaybeMessage<Workload>(nullptr);
  }

  Workload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Workload>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Workload& from);
  void MergeFrom(const Workload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Workload* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.Workload";
  }
  protected:
  explicit Workload(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitStoreFieldNumber = 1,
    kFillTypesFieldNumber = 2,
    kFillNodesFieldNumber = 3,
    kFillEdgesFieldNumber = 4,
    kReadTypesFieldNumber = 5,
    kReadNodesFieldNumber = 6,
    kReadEdgesFieldNumber = 7,
  };
  // .ml_metadata.InitStore init_store = 1;
  bool has_init_store() const;
  private:
  bool _internal_has_init_store() const;
  public:
  void clear_init_store();
  const ::ml_metadata::InitStore& init_store() const;
  ::ml_metadata::InitStore* release_init_store();
  ::ml_metadata::InitStore* mutable_init_store();
  void set_allocated_init_store(::ml_metadata::InitStore* init_store);
  private:
  const ::ml_metadata::InitStore& _internal_init_store() const;
  ::ml_metadata::InitStore* _internal_mutable_init_store();
  public:
  void unsafe_arena_set_allocated_init_store(
      ::ml_metadata::InitStore* init_store);
  ::ml_metadata::InitStore* unsafe_arena_release_init_store();

  // .ml_metadata.FillTypes fill_types = 2;
  bool has_fill_types() const;
  private:
  bool _internal_has_fill_types() const;
  public:
  void clear_fill_types();
  const ::ml_metadata::FillTypes& fill_types() const;
  ::ml_metadata::FillTypes* release_fill_types();
  ::ml_metadata::FillTypes* mutable_fill_types();
  void set_allocated_fill_types(::ml_metadata::FillTypes* fill_types);
  private:
  const ::ml_metadata::FillTypes& _internal_fill_types() const;
  ::ml_metadata::FillTypes* _internal_mutable_fill_types();
  public:
  void unsafe_arena_set_allocated_fill_types(
      ::ml_metadata::FillTypes* fill_types);
  ::ml_metadata::FillTypes* unsafe_arena_release_fill_types();

  // .ml_metadata.FillNodes fill_nodes = 3;
  bool has_fill_nodes() const;
  private:
  bool _internal_has_fill_nodes() const;
  public:
  void clear_fill_nodes();
  const ::ml_metadata::FillNodes& fill_nodes() const;
  ::ml_metadata::FillNodes* release_fill_nodes();
  ::ml_metadata::FillNodes* mutable_fill_nodes();
  void set_allocated_fill_nodes(::ml_metadata::FillNodes* fill_nodes);
  private:
  const ::ml_metadata::FillNodes& _internal_fill_nodes() const;
  ::ml_metadata::FillNodes* _internal_mutable_fill_nodes();
  public:
  void unsafe_arena_set_allocated_fill_nodes(
      ::ml_metadata::FillNodes* fill_nodes);
  ::ml_metadata::FillNodes* unsafe_arena_release_fill_nodes();

  // .ml_metadata.FillEdges fill_edges = 4;
  bool has_fill_edges() const;
  private:
  bool _internal_has_fill_edges() const;
  public:
  void clear_fill_edges();
  const ::ml_metadata::FillEdges& fill_edges() const;
  ::ml_metadata::FillEdges* release_fill_edges();
  ::ml_metadata::FillEdges* mutable_fill_edges();
  void set_allocated_fill_edges(::ml_metadata::FillEdges* fill_edges);
  private:
  const ::ml_metadata::FillEdges& _internal_fill_edges() const;
  ::ml_metadata::FillEdges* _internal_mutable_fill_edges();
  public:
  void unsafe_arena_set_allocated_fill_edges(
      ::ml_metadata::FillEdges* fill_edges);
  ::ml_metadata::FillEdges* unsafe_arena_release_fill_edges();

  // .ml_metadata.ReadTypes read_types = 5;
  bool has_read_types() const;
  private:
  bool _internal_has_read_types() const;
  public:
  void clear_read_types();
  const ::ml_metadata::ReadTypes& read_types() const;
  ::ml_metadata::ReadTypes* release_read_types();
  ::ml_metadata::ReadTypes* mutable_read_types();
  void set_allocated_read_types(::ml_metadata::ReadTypes* read_types);
  private:
  const ::ml_metadata::ReadTypes& _internal_read_types() const;
  ::ml_metadata::ReadTypes* _internal_mutable_read_types();
  public:
  void unsafe_arena_set_allocated_read_types(
      ::ml_metadata::ReadTypes* read_types);
  ::ml_metadata::ReadTypes* unsafe_arena_release_read_types();

  // .ml_metadata.ReadNodes read_nodes = 6;
  bool has_read_nodes() const;
  private:
  bool _internal_has_read_nodes() const;
  public:
  void clear_read_nodes();
  const ::ml_metadata::ReadNodes& read_nodes() const;
  ::ml_metadata::ReadNodes* release_read_nodes();
  ::ml_metadata::ReadNodes* mutable_read_nodes();
  void set_allocated_read_nodes(::ml_metadata::ReadNodes* read_nodes);
  private:
  const ::ml_metadata::ReadNodes& _internal_read_nodes() const;
  ::ml_metadata::ReadNodes* _internal_mutable_read_nodes();
  public:
  void unsafe_arena_set_allocated_read_nodes(
      ::ml_metadata::ReadNodes* read_nodes);
  ::ml_metadata::ReadNodes* unsafe_arena_release_read_nodes();

  // .ml_metadata.ReadEdges read_edges = 7;
  bool has_read_edges() const;
  private:
  bool _internal_has_read_edges() const;
  public:
  void clear_read_edges();
  const ::ml_metadata::ReadEdges& read_edges() const;
  ::ml_metadata::ReadEdges* release_read_edges();
  ::ml_metadata::ReadEdges* mutable_read_edges();
  void set_allocated_read_edges(::ml_metadata::ReadEdges* read_edges);
  private:
  const ::ml_metadata::ReadEdges& _internal_read_edges() const;
  ::ml_metadata::ReadEdges* _internal_mutable_read_edges();
  public:
  void unsafe_arena_set_allocated_read_edges(
      ::ml_metadata::ReadEdges* read_edges);
  ::ml_metadata::ReadEdges* unsafe_arena_release_read_edges();

  void clear_workloads();
  WorkloadsCase workloads_case() const;
  // @@protoc_insertion_point(class_scope:ml_metadata.Workload)
 private:
  class _Internal;
  void set_has_init_store();
  void set_has_fill_types();
  void set_has_fill_nodes();
  void set_has_fill_edges();
  void set_has_read_types();
  void set_has_read_nodes();
  void set_has_read_edges();

  inline bool has_workloads() const;
  inline void clear_has_workloads();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union WorkloadsUnion {
    WorkloadsUnion() {}
    ::ml_metadata::InitStore* init_store_;
    ::ml_metadata::FillTypes* fill_types_;
    ::ml_metadata::FillNodes* fill_nodes_;
    ::ml_metadata::FillEdges* fill_edges_;
    ::ml_metadata::ReadTypes* read_types_;
    ::ml_metadata::ReadNodes* read_nodes_;
    ::ml_metadata::ReadEdges* read_edges_;
  } workloads_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class ThreadEnv PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.ThreadEnv) */ {
 public:
  inline ThreadEnv() : ThreadEnv(nullptr) {};
  virtual ~ThreadEnv();

  ThreadEnv(const ThreadEnv& from);
  ThreadEnv(ThreadEnv&& from) noexcept
    : ThreadEnv() {
    *this = ::std::move(from);
  }

  inline ThreadEnv& operator=(const ThreadEnv& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreadEnv& operator=(ThreadEnv&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThreadEnv& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThreadEnv* internal_default_instance() {
    return reinterpret_cast<const ThreadEnv*>(
               &_ThreadEnv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ThreadEnv& a, ThreadEnv& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreadEnv* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreadEnv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThreadEnv* New() const final {
    return CreateMaybeMessage<ThreadEnv>(nullptr);
  }

  ThreadEnv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThreadEnv>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThreadEnv& from);
  void MergeFrom(const ThreadEnv& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThreadEnv* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.ThreadEnv";
  }
  protected:
  explicit ThreadEnv(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreadNumFieldNumber = 1,
  };
  // optional int32 thread_num = 1;
  bool has_thread_num() const;
  private:
  bool _internal_has_thread_num() const;
  public:
  void clear_thread_num();
  ::PROTOBUF_NAMESPACE_ID::int32 thread_num() const;
  void set_thread_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_thread_num() const;
  void _internal_set_thread_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.ThreadEnv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 thread_num_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class MLMDBenchReport PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.MLMDBenchReport) */ {
 public:
  inline MLMDBenchReport() : MLMDBenchReport(nullptr) {};
  virtual ~MLMDBenchReport();

  MLMDBenchReport(const MLMDBenchReport& from);
  MLMDBenchReport(MLMDBenchReport&& from) noexcept
    : MLMDBenchReport() {
    *this = ::std::move(from);
  }

  inline MLMDBenchReport& operator=(const MLMDBenchReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline MLMDBenchReport& operator=(MLMDBenchReport&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MLMDBenchReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MLMDBenchReport* internal_default_instance() {
    return reinterpret_cast<const MLMDBenchReport*>(
               &_MLMDBenchReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MLMDBenchReport& a, MLMDBenchReport& b) {
    a.Swap(&b);
  }
  inline void Swap(MLMDBenchReport* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MLMDBenchReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MLMDBenchReport* New() const final {
    return CreateMaybeMessage<MLMDBenchReport>(nullptr);
  }

  MLMDBenchReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MLMDBenchReport>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MLMDBenchReport& from);
  void MergeFrom(const MLMDBenchReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MLMDBenchReport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.MLMDBenchReport";
  }
  protected:
  explicit MLMDBenchReport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSummariesFieldNumber = 1,
  };
  // repeated .ml_metadata.WorkloadResult summaries = 1;
  int summaries_size() const;
  private:
  int _internal_summaries_size() const;
  public:
  void clear_summaries();
  ::ml_metadata::WorkloadResult* mutable_summaries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::WorkloadResult >*
      mutable_summaries();
  private:
  const ::ml_metadata::WorkloadResult& _internal_summaries(int index) const;
  ::ml_metadata::WorkloadResult* _internal_add_summaries();
  public:
  const ::ml_metadata::WorkloadResult& summaries(int index) const;
  ::ml_metadata::WorkloadResult* add_summaries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::WorkloadResult >&
      summaries() const;

  // @@protoc_insertion_point(class_scope:ml_metadata.MLMDBenchReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::WorkloadResult > summaries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// -------------------------------------------------------------------

class WorkloadResult PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ml_metadata.WorkloadResult) */ {
 public:
  inline WorkloadResult() : WorkloadResult(nullptr) {};
  virtual ~WorkloadResult();

  WorkloadResult(const WorkloadResult& from);
  WorkloadResult(WorkloadResult&& from) noexcept
    : WorkloadResult() {
    *this = ::std::move(from);
  }

  inline WorkloadResult& operator=(const WorkloadResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkloadResult& operator=(WorkloadResult&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorkloadResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkloadResult* internal_default_instance() {
    return reinterpret_cast<const WorkloadResult*>(
               &_WorkloadResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(WorkloadResult& a, WorkloadResult& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkloadResult* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkloadResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorkloadResult* New() const final {
    return CreateMaybeMessage<WorkloadResult>(nullptr);
  }

  WorkloadResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorkloadResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorkloadResult& from);
  void MergeFrom(const WorkloadResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkloadResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ml_metadata.WorkloadResult";
  }
  protected:
  explicit WorkloadResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_metadata_5fbench_2eproto);
    return ::descriptor_table_metadata_5fbench_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorkloadFieldNumber = 1,
    kMicrosecondPerOpFieldNumber = 2,
    kBytesPerSecondFieldNumber = 3,
  };
  // optional .ml_metadata.Workload workload = 1;
  bool has_workload() const;
  private:
  bool _internal_has_workload() const;
  public:
  void clear_workload();
  const ::ml_metadata::Workload& workload() const;
  ::ml_metadata::Workload* release_workload();
  ::ml_metadata::Workload* mutable_workload();
  void set_allocated_workload(::ml_metadata::Workload* workload);
  private:
  const ::ml_metadata::Workload& _internal_workload() const;
  ::ml_metadata::Workload* _internal_mutable_workload();
  public:
  void unsafe_arena_set_allocated_workload(
      ::ml_metadata::Workload* workload);
  ::ml_metadata::Workload* unsafe_arena_release_workload();

  // optional double microsecond_per_op = 2;
  bool has_microsecond_per_op() const;
  private:
  bool _internal_has_microsecond_per_op() const;
  public:
  void clear_microsecond_per_op();
  double microsecond_per_op() const;
  void set_microsecond_per_op(double value);
  private:
  double _internal_microsecond_per_op() const;
  void _internal_set_microsecond_per_op(double value);
  public:

  // optional double bytes_per_second = 3;
  bool has_bytes_per_second() const;
  private:
  bool _internal_has_bytes_per_second() const;
  public:
  void clear_bytes_per_second();
  double bytes_per_second() const;
  void set_bytes_per_second(double value);
  private:
  double _internal_bytes_per_second() const;
  void _internal_set_bytes_per_second(double value);
  public:

  // @@protoc_insertion_point(class_scope:ml_metadata.WorkloadResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::ml_metadata::Workload* workload_;
  double microsecond_per_op_;
  double bytes_per_second_;
  friend struct ::TableStruct_metadata_5fbench_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MLMDBenchConfig

// optional .ml_metadata.ConnectionConfig mlmd_config = 1;
inline bool MLMDBenchConfig::_internal_has_mlmd_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || mlmd_config_ != nullptr);
  return value;
}
inline bool MLMDBenchConfig::has_mlmd_config() const {
  return _internal_has_mlmd_config();
}
inline const ::ml_metadata::ConnectionConfig& MLMDBenchConfig::_internal_mlmd_config() const {
  const ::ml_metadata::ConnectionConfig* p = mlmd_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::ConnectionConfig*>(
      &::ml_metadata::_ConnectionConfig_default_instance_);
}
inline const ::ml_metadata::ConnectionConfig& MLMDBenchConfig::mlmd_config() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MLMDBenchConfig.mlmd_config)
  return _internal_mlmd_config();
}
inline void MLMDBenchConfig::unsafe_arena_set_allocated_mlmd_config(
    ::ml_metadata::ConnectionConfig* mlmd_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlmd_config_);
  }
  mlmd_config_ = mlmd_config;
  if (mlmd_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MLMDBenchConfig.mlmd_config)
}
inline ::ml_metadata::ConnectionConfig* MLMDBenchConfig::release_mlmd_config() {
  auto temp = unsafe_arena_release_mlmd_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::ConnectionConfig* MLMDBenchConfig::unsafe_arena_release_mlmd_config() {
  // @@protoc_insertion_point(field_release:ml_metadata.MLMDBenchConfig.mlmd_config)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ConnectionConfig* temp = mlmd_config_;
  mlmd_config_ = nullptr;
  return temp;
}
inline ::ml_metadata::ConnectionConfig* MLMDBenchConfig::_internal_mutable_mlmd_config() {
  _has_bits_[0] |= 0x00000001u;
  if (mlmd_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ConnectionConfig>(GetArena());
    mlmd_config_ = p;
  }
  return mlmd_config_;
}
inline ::ml_metadata::ConnectionConfig* MLMDBenchConfig::mutable_mlmd_config() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.MLMDBenchConfig.mlmd_config)
  return _internal_mutable_mlmd_config();
}
inline void MLMDBenchConfig::set_allocated_mlmd_config(::ml_metadata::ConnectionConfig* mlmd_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlmd_config_);
  }
  if (mlmd_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlmd_config)->GetArena();
    if (message_arena != submessage_arena) {
      mlmd_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mlmd_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mlmd_config_ = mlmd_config;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MLMDBenchConfig.mlmd_config)
}

// repeated .ml_metadata.Workload workloads = 2;
inline int MLMDBenchConfig::_internal_workloads_size() const {
  return workloads_.size();
}
inline int MLMDBenchConfig::workloads_size() const {
  return _internal_workloads_size();
}
inline void MLMDBenchConfig::clear_workloads() {
  workloads_.Clear();
}
inline ::ml_metadata::Workload* MLMDBenchConfig::mutable_workloads(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.MLMDBenchConfig.workloads)
  return workloads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Workload >*
MLMDBenchConfig::mutable_workloads() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.MLMDBenchConfig.workloads)
  return &workloads_;
}
inline const ::ml_metadata::Workload& MLMDBenchConfig::_internal_workloads(int index) const {
  return workloads_.Get(index);
}
inline const ::ml_metadata::Workload& MLMDBenchConfig::workloads(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.MLMDBenchConfig.workloads)
  return _internal_workloads(index);
}
inline ::ml_metadata::Workload* MLMDBenchConfig::_internal_add_workloads() {
  return workloads_.Add();
}
inline ::ml_metadata::Workload* MLMDBenchConfig::add_workloads() {
  // @@protoc_insertion_point(field_add:ml_metadata.MLMDBenchConfig.workloads)
  return _internal_add_workloads();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::Workload >&
MLMDBenchConfig::workloads() const {
  // @@protoc_insertion_point(field_list:ml_metadata.MLMDBenchConfig.workloads)
  return workloads_;
}

// optional .ml_metadata.ThreadEnv thread_env = 3;
inline bool MLMDBenchConfig::_internal_has_thread_env() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || thread_env_ != nullptr);
  return value;
}
inline bool MLMDBenchConfig::has_thread_env() const {
  return _internal_has_thread_env();
}
inline void MLMDBenchConfig::clear_thread_env() {
  if (thread_env_ != nullptr) thread_env_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ml_metadata::ThreadEnv& MLMDBenchConfig::_internal_thread_env() const {
  const ::ml_metadata::ThreadEnv* p = thread_env_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::ThreadEnv*>(
      &::ml_metadata::_ThreadEnv_default_instance_);
}
inline const ::ml_metadata::ThreadEnv& MLMDBenchConfig::thread_env() const {
  // @@protoc_insertion_point(field_get:ml_metadata.MLMDBenchConfig.thread_env)
  return _internal_thread_env();
}
inline void MLMDBenchConfig::unsafe_arena_set_allocated_thread_env(
    ::ml_metadata::ThreadEnv* thread_env) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thread_env_);
  }
  thread_env_ = thread_env;
  if (thread_env) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.MLMDBenchConfig.thread_env)
}
inline ::ml_metadata::ThreadEnv* MLMDBenchConfig::release_thread_env() {
  auto temp = unsafe_arena_release_thread_env();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::ThreadEnv* MLMDBenchConfig::unsafe_arena_release_thread_env() {
  // @@protoc_insertion_point(field_release:ml_metadata.MLMDBenchConfig.thread_env)
  _has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::ThreadEnv* temp = thread_env_;
  thread_env_ = nullptr;
  return temp;
}
inline ::ml_metadata::ThreadEnv* MLMDBenchConfig::_internal_mutable_thread_env() {
  _has_bits_[0] |= 0x00000002u;
  if (thread_env_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ThreadEnv>(GetArena());
    thread_env_ = p;
  }
  return thread_env_;
}
inline ::ml_metadata::ThreadEnv* MLMDBenchConfig::mutable_thread_env() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.MLMDBenchConfig.thread_env)
  return _internal_mutable_thread_env();
}
inline void MLMDBenchConfig::set_allocated_thread_env(::ml_metadata::ThreadEnv* thread_env) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete thread_env_;
  }
  if (thread_env) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(thread_env);
    if (message_arena != submessage_arena) {
      thread_env = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thread_env, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  thread_env_ = thread_env;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.MLMDBenchConfig.thread_env)
}

// -------------------------------------------------------------------

// UniformDistribution

// optional int32 range_begin = 1 [default = 1];
inline bool UniformDistribution::_internal_has_range_begin() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UniformDistribution::has_range_begin() const {
  return _internal_has_range_begin();
}
inline void UniformDistribution::clear_range_begin() {
  range_begin_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UniformDistribution::_internal_range_begin() const {
  return range_begin_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UniformDistribution::range_begin() const {
  // @@protoc_insertion_point(field_get:ml_metadata.UniformDistribution.range_begin)
  return _internal_range_begin();
}
inline void UniformDistribution::_internal_set_range_begin(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  range_begin_ = value;
}
inline void UniformDistribution::set_range_begin(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_range_begin(value);
  // @@protoc_insertion_point(field_set:ml_metadata.UniformDistribution.range_begin)
}

// optional int32 range_end = 2 [default = 10];
inline bool UniformDistribution::_internal_has_range_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UniformDistribution::has_range_end() const {
  return _internal_has_range_end();
}
inline void UniformDistribution::clear_range_end() {
  range_end_ = 10;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UniformDistribution::_internal_range_end() const {
  return range_end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UniformDistribution::range_end() const {
  // @@protoc_insertion_point(field_get:ml_metadata.UniformDistribution.range_end)
  return _internal_range_end();
}
inline void UniformDistribution::_internal_set_range_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  range_end_ = value;
}
inline void UniformDistribution::set_range_end(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_range_end(value);
  // @@protoc_insertion_point(field_set:ml_metadata.UniformDistribution.range_end)
}

// -------------------------------------------------------------------

// NormalDistribution

// optional int32 coefficient_of_variation = 1 [default = 5];
inline bool NormalDistribution::_internal_has_coefficient_of_variation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NormalDistribution::has_coefficient_of_variation() const {
  return _internal_has_coefficient_of_variation();
}
inline void NormalDistribution::clear_coefficient_of_variation() {
  coefficient_of_variation_ = 5;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NormalDistribution::_internal_coefficient_of_variation() const {
  return coefficient_of_variation_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NormalDistribution::coefficient_of_variation() const {
  // @@protoc_insertion_point(field_get:ml_metadata.NormalDistribution.coefficient_of_variation)
  return _internal_coefficient_of_variation();
}
inline void NormalDistribution::_internal_set_coefficient_of_variation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  coefficient_of_variation_ = value;
}
inline void NormalDistribution::set_coefficient_of_variation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_coefficient_of_variation(value);
  // @@protoc_insertion_point(field_set:ml_metadata.NormalDistribution.coefficient_of_variation)
}

// -------------------------------------------------------------------

// InitStore

// optional .ml_metadata.ConnectionConfig mlmd_config = 1;
inline bool InitStore::_internal_has_mlmd_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || mlmd_config_ != nullptr);
  return value;
}
inline bool InitStore::has_mlmd_config() const {
  return _internal_has_mlmd_config();
}
inline const ::ml_metadata::ConnectionConfig& InitStore::_internal_mlmd_config() const {
  const ::ml_metadata::ConnectionConfig* p = mlmd_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::ConnectionConfig*>(
      &::ml_metadata::_ConnectionConfig_default_instance_);
}
inline const ::ml_metadata::ConnectionConfig& InitStore::mlmd_config() const {
  // @@protoc_insertion_point(field_get:ml_metadata.InitStore.mlmd_config)
  return _internal_mlmd_config();
}
inline void InitStore::unsafe_arena_set_allocated_mlmd_config(
    ::ml_metadata::ConnectionConfig* mlmd_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlmd_config_);
  }
  mlmd_config_ = mlmd_config;
  if (mlmd_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.InitStore.mlmd_config)
}
inline ::ml_metadata::ConnectionConfig* InitStore::release_mlmd_config() {
  auto temp = unsafe_arena_release_mlmd_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::ConnectionConfig* InitStore::unsafe_arena_release_mlmd_config() {
  // @@protoc_insertion_point(field_release:ml_metadata.InitStore.mlmd_config)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::ConnectionConfig* temp = mlmd_config_;
  mlmd_config_ = nullptr;
  return temp;
}
inline ::ml_metadata::ConnectionConfig* InitStore::_internal_mutable_mlmd_config() {
  _has_bits_[0] |= 0x00000001u;
  if (mlmd_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::ConnectionConfig>(GetArena());
    mlmd_config_ = p;
  }
  return mlmd_config_;
}
inline ::ml_metadata::ConnectionConfig* InitStore::mutable_mlmd_config() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.InitStore.mlmd_config)
  return _internal_mutable_mlmd_config();
}
inline void InitStore::set_allocated_mlmd_config(::ml_metadata::ConnectionConfig* mlmd_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlmd_config_);
  }
  if (mlmd_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mlmd_config)->GetArena();
    if (message_arena != submessage_arena) {
      mlmd_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mlmd_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mlmd_config_ = mlmd_config;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.InitStore.mlmd_config)
}

// -------------------------------------------------------------------

// FillTypes

// optional bool update = 1 [default = false];
inline bool FillTypes::_internal_has_update() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FillTypes::has_update() const {
  return _internal_has_update();
}
inline void FillTypes::clear_update() {
  update_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FillTypes::_internal_update() const {
  return update_;
}
inline bool FillTypes::update() const {
  // @@protoc_insertion_point(field_get:ml_metadata.FillTypes.update)
  return _internal_update();
}
inline void FillTypes::_internal_set_update(bool value) {
  _has_bits_[0] |= 0x00000002u;
  update_ = value;
}
inline void FillTypes::set_update(bool value) {
  _internal_set_update(value);
  // @@protoc_insertion_point(field_set:ml_metadata.FillTypes.update)
}

// optional .ml_metadata.UniformDistribution num_properties = 2;
inline bool FillTypes::_internal_has_num_properties() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || num_properties_ != nullptr);
  return value;
}
inline bool FillTypes::has_num_properties() const {
  return _internal_has_num_properties();
}
inline void FillTypes::clear_num_properties() {
  if (num_properties_ != nullptr) num_properties_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::UniformDistribution& FillTypes::_internal_num_properties() const {
  const ::ml_metadata::UniformDistribution* p = num_properties_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::UniformDistribution*>(
      &::ml_metadata::_UniformDistribution_default_instance_);
}
inline const ::ml_metadata::UniformDistribution& FillTypes::num_properties() const {
  // @@protoc_insertion_point(field_get:ml_metadata.FillTypes.num_properties)
  return _internal_num_properties();
}
inline void FillTypes::unsafe_arena_set_allocated_num_properties(
    ::ml_metadata::UniformDistribution* num_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(num_properties_);
  }
  num_properties_ = num_properties;
  if (num_properties) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.FillTypes.num_properties)
}
inline ::ml_metadata::UniformDistribution* FillTypes::release_num_properties() {
  auto temp = unsafe_arena_release_num_properties();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::UniformDistribution* FillTypes::unsafe_arena_release_num_properties() {
  // @@protoc_insertion_point(field_release:ml_metadata.FillTypes.num_properties)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::UniformDistribution* temp = num_properties_;
  num_properties_ = nullptr;
  return temp;
}
inline ::ml_metadata::UniformDistribution* FillTypes::_internal_mutable_num_properties() {
  _has_bits_[0] |= 0x00000001u;
  if (num_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::UniformDistribution>(GetArena());
    num_properties_ = p;
  }
  return num_properties_;
}
inline ::ml_metadata::UniformDistribution* FillTypes::mutable_num_properties() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.FillTypes.num_properties)
  return _internal_mutable_num_properties();
}
inline void FillTypes::set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete num_properties_;
  }
  if (num_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(num_properties);
    if (message_arena != submessage_arena) {
      num_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, num_properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  num_properties_ = num_properties;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.FillTypes.num_properties)
}

// -------------------------------------------------------------------

// FillNodes

// optional bool update = 1 [default = false];
inline bool FillNodes::_internal_has_update() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FillNodes::has_update() const {
  return _internal_has_update();
}
inline void FillNodes::clear_update() {
  update_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FillNodes::_internal_update() const {
  return update_;
}
inline bool FillNodes::update() const {
  // @@protoc_insertion_point(field_get:ml_metadata.FillNodes.update)
  return _internal_update();
}
inline void FillNodes::_internal_set_update(bool value) {
  _has_bits_[0] |= 0x00000002u;
  update_ = value;
}
inline void FillNodes::set_update(bool value) {
  _internal_set_update(value);
  // @@protoc_insertion_point(field_set:ml_metadata.FillNodes.update)
}

// optional .ml_metadata.UniformDistribution num_properties = 2;
inline bool FillNodes::_internal_has_num_properties() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || num_properties_ != nullptr);
  return value;
}
inline bool FillNodes::has_num_properties() const {
  return _internal_has_num_properties();
}
inline void FillNodes::clear_num_properties() {
  if (num_properties_ != nullptr) num_properties_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::UniformDistribution& FillNodes::_internal_num_properties() const {
  const ::ml_metadata::UniformDistribution* p = num_properties_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::UniformDistribution*>(
      &::ml_metadata::_UniformDistribution_default_instance_);
}
inline const ::ml_metadata::UniformDistribution& FillNodes::num_properties() const {
  // @@protoc_insertion_point(field_get:ml_metadata.FillNodes.num_properties)
  return _internal_num_properties();
}
inline void FillNodes::unsafe_arena_set_allocated_num_properties(
    ::ml_metadata::UniformDistribution* num_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(num_properties_);
  }
  num_properties_ = num_properties;
  if (num_properties) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.FillNodes.num_properties)
}
inline ::ml_metadata::UniformDistribution* FillNodes::release_num_properties() {
  auto temp = unsafe_arena_release_num_properties();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::UniformDistribution* FillNodes::unsafe_arena_release_num_properties() {
  // @@protoc_insertion_point(field_release:ml_metadata.FillNodes.num_properties)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::UniformDistribution* temp = num_properties_;
  num_properties_ = nullptr;
  return temp;
}
inline ::ml_metadata::UniformDistribution* FillNodes::_internal_mutable_num_properties() {
  _has_bits_[0] |= 0x00000001u;
  if (num_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::UniformDistribution>(GetArena());
    num_properties_ = p;
  }
  return num_properties_;
}
inline ::ml_metadata::UniformDistribution* FillNodes::mutable_num_properties() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.FillNodes.num_properties)
  return _internal_mutable_num_properties();
}
inline void FillNodes::set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete num_properties_;
  }
  if (num_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(num_properties);
    if (message_arena != submessage_arena) {
      num_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, num_properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  num_properties_ = num_properties;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.FillNodes.num_properties)
}

// -------------------------------------------------------------------

// FillEdges

// optional .ml_metadata.NormalDistribution bipartite_distribution1 = 1;
inline bool FillEdges::_internal_has_bipartite_distribution1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bipartite_distribution1_ != nullptr);
  return value;
}
inline bool FillEdges::has_bipartite_distribution1() const {
  return _internal_has_bipartite_distribution1();
}
inline void FillEdges::clear_bipartite_distribution1() {
  if (bipartite_distribution1_ != nullptr) bipartite_distribution1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::NormalDistribution& FillEdges::_internal_bipartite_distribution1() const {
  const ::ml_metadata::NormalDistribution* p = bipartite_distribution1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::NormalDistribution*>(
      &::ml_metadata::_NormalDistribution_default_instance_);
}
inline const ::ml_metadata::NormalDistribution& FillEdges::bipartite_distribution1() const {
  // @@protoc_insertion_point(field_get:ml_metadata.FillEdges.bipartite_distribution1)
  return _internal_bipartite_distribution1();
}
inline void FillEdges::unsafe_arena_set_allocated_bipartite_distribution1(
    ::ml_metadata::NormalDistribution* bipartite_distribution1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bipartite_distribution1_);
  }
  bipartite_distribution1_ = bipartite_distribution1;
  if (bipartite_distribution1) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.FillEdges.bipartite_distribution1)
}
inline ::ml_metadata::NormalDistribution* FillEdges::release_bipartite_distribution1() {
  auto temp = unsafe_arena_release_bipartite_distribution1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::NormalDistribution* FillEdges::unsafe_arena_release_bipartite_distribution1() {
  // @@protoc_insertion_point(field_release:ml_metadata.FillEdges.bipartite_distribution1)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::NormalDistribution* temp = bipartite_distribution1_;
  bipartite_distribution1_ = nullptr;
  return temp;
}
inline ::ml_metadata::NormalDistribution* FillEdges::_internal_mutable_bipartite_distribution1() {
  _has_bits_[0] |= 0x00000001u;
  if (bipartite_distribution1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::NormalDistribution>(GetArena());
    bipartite_distribution1_ = p;
  }
  return bipartite_distribution1_;
}
inline ::ml_metadata::NormalDistribution* FillEdges::mutable_bipartite_distribution1() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.FillEdges.bipartite_distribution1)
  return _internal_mutable_bipartite_distribution1();
}
inline void FillEdges::set_allocated_bipartite_distribution1(::ml_metadata::NormalDistribution* bipartite_distribution1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bipartite_distribution1_;
  }
  if (bipartite_distribution1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bipartite_distribution1);
    if (message_arena != submessage_arena) {
      bipartite_distribution1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bipartite_distribution1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bipartite_distribution1_ = bipartite_distribution1;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.FillEdges.bipartite_distribution1)
}

// optional .ml_metadata.NormalDistribution bipartite_distribution2 = 2;
inline bool FillEdges::_internal_has_bipartite_distribution2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || bipartite_distribution2_ != nullptr);
  return value;
}
inline bool FillEdges::has_bipartite_distribution2() const {
  return _internal_has_bipartite_distribution2();
}
inline void FillEdges::clear_bipartite_distribution2() {
  if (bipartite_distribution2_ != nullptr) bipartite_distribution2_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ml_metadata::NormalDistribution& FillEdges::_internal_bipartite_distribution2() const {
  const ::ml_metadata::NormalDistribution* p = bipartite_distribution2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::NormalDistribution*>(
      &::ml_metadata::_NormalDistribution_default_instance_);
}
inline const ::ml_metadata::NormalDistribution& FillEdges::bipartite_distribution2() const {
  // @@protoc_insertion_point(field_get:ml_metadata.FillEdges.bipartite_distribution2)
  return _internal_bipartite_distribution2();
}
inline void FillEdges::unsafe_arena_set_allocated_bipartite_distribution2(
    ::ml_metadata::NormalDistribution* bipartite_distribution2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bipartite_distribution2_);
  }
  bipartite_distribution2_ = bipartite_distribution2;
  if (bipartite_distribution2) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.FillEdges.bipartite_distribution2)
}
inline ::ml_metadata::NormalDistribution* FillEdges::release_bipartite_distribution2() {
  auto temp = unsafe_arena_release_bipartite_distribution2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::NormalDistribution* FillEdges::unsafe_arena_release_bipartite_distribution2() {
  // @@protoc_insertion_point(field_release:ml_metadata.FillEdges.bipartite_distribution2)
  _has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::NormalDistribution* temp = bipartite_distribution2_;
  bipartite_distribution2_ = nullptr;
  return temp;
}
inline ::ml_metadata::NormalDistribution* FillEdges::_internal_mutable_bipartite_distribution2() {
  _has_bits_[0] |= 0x00000002u;
  if (bipartite_distribution2_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::NormalDistribution>(GetArena());
    bipartite_distribution2_ = p;
  }
  return bipartite_distribution2_;
}
inline ::ml_metadata::NormalDistribution* FillEdges::mutable_bipartite_distribution2() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.FillEdges.bipartite_distribution2)
  return _internal_mutable_bipartite_distribution2();
}
inline void FillEdges::set_allocated_bipartite_distribution2(::ml_metadata::NormalDistribution* bipartite_distribution2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bipartite_distribution2_;
  }
  if (bipartite_distribution2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bipartite_distribution2);
    if (message_arena != submessage_arena) {
      bipartite_distribution2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bipartite_distribution2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bipartite_distribution2_ = bipartite_distribution2;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.FillEdges.bipartite_distribution2)
}

// -------------------------------------------------------------------

// ReadTypes

// optional .ml_metadata.UniformDistribution num_properties = 1;
inline bool ReadTypes::_internal_has_num_properties() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || num_properties_ != nullptr);
  return value;
}
inline bool ReadTypes::has_num_properties() const {
  return _internal_has_num_properties();
}
inline void ReadTypes::clear_num_properties() {
  if (num_properties_ != nullptr) num_properties_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::UniformDistribution& ReadTypes::_internal_num_properties() const {
  const ::ml_metadata::UniformDistribution* p = num_properties_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::UniformDistribution*>(
      &::ml_metadata::_UniformDistribution_default_instance_);
}
inline const ::ml_metadata::UniformDistribution& ReadTypes::num_properties() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ReadTypes.num_properties)
  return _internal_num_properties();
}
inline void ReadTypes::unsafe_arena_set_allocated_num_properties(
    ::ml_metadata::UniformDistribution* num_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(num_properties_);
  }
  num_properties_ = num_properties;
  if (num_properties) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ReadTypes.num_properties)
}
inline ::ml_metadata::UniformDistribution* ReadTypes::release_num_properties() {
  auto temp = unsafe_arena_release_num_properties();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::UniformDistribution* ReadTypes::unsafe_arena_release_num_properties() {
  // @@protoc_insertion_point(field_release:ml_metadata.ReadTypes.num_properties)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::UniformDistribution* temp = num_properties_;
  num_properties_ = nullptr;
  return temp;
}
inline ::ml_metadata::UniformDistribution* ReadTypes::_internal_mutable_num_properties() {
  _has_bits_[0] |= 0x00000001u;
  if (num_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::UniformDistribution>(GetArena());
    num_properties_ = p;
  }
  return num_properties_;
}
inline ::ml_metadata::UniformDistribution* ReadTypes::mutable_num_properties() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.ReadTypes.num_properties)
  return _internal_mutable_num_properties();
}
inline void ReadTypes::set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete num_properties_;
  }
  if (num_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(num_properties);
    if (message_arena != submessage_arena) {
      num_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, num_properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  num_properties_ = num_properties;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ReadTypes.num_properties)
}

// -------------------------------------------------------------------

// ReadNodes

// optional .ml_metadata.UniformDistribution num_properties = 1;
inline bool ReadNodes::_internal_has_num_properties() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || num_properties_ != nullptr);
  return value;
}
inline bool ReadNodes::has_num_properties() const {
  return _internal_has_num_properties();
}
inline void ReadNodes::clear_num_properties() {
  if (num_properties_ != nullptr) num_properties_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::UniformDistribution& ReadNodes::_internal_num_properties() const {
  const ::ml_metadata::UniformDistribution* p = num_properties_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::UniformDistribution*>(
      &::ml_metadata::_UniformDistribution_default_instance_);
}
inline const ::ml_metadata::UniformDistribution& ReadNodes::num_properties() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ReadNodes.num_properties)
  return _internal_num_properties();
}
inline void ReadNodes::unsafe_arena_set_allocated_num_properties(
    ::ml_metadata::UniformDistribution* num_properties) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(num_properties_);
  }
  num_properties_ = num_properties;
  if (num_properties) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ReadNodes.num_properties)
}
inline ::ml_metadata::UniformDistribution* ReadNodes::release_num_properties() {
  auto temp = unsafe_arena_release_num_properties();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::UniformDistribution* ReadNodes::unsafe_arena_release_num_properties() {
  // @@protoc_insertion_point(field_release:ml_metadata.ReadNodes.num_properties)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::UniformDistribution* temp = num_properties_;
  num_properties_ = nullptr;
  return temp;
}
inline ::ml_metadata::UniformDistribution* ReadNodes::_internal_mutable_num_properties() {
  _has_bits_[0] |= 0x00000001u;
  if (num_properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::UniformDistribution>(GetArena());
    num_properties_ = p;
  }
  return num_properties_;
}
inline ::ml_metadata::UniformDistribution* ReadNodes::mutable_num_properties() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.ReadNodes.num_properties)
  return _internal_mutable_num_properties();
}
inline void ReadNodes::set_allocated_num_properties(::ml_metadata::UniformDistribution* num_properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete num_properties_;
  }
  if (num_properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(num_properties);
    if (message_arena != submessage_arena) {
      num_properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, num_properties, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  num_properties_ = num_properties;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ReadNodes.num_properties)
}

// -------------------------------------------------------------------

// ReadEdges

// optional .ml_metadata.NormalDistribution bipartite_distribution1 = 1;
inline bool ReadEdges::_internal_has_bipartite_distribution1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bipartite_distribution1_ != nullptr);
  return value;
}
inline bool ReadEdges::has_bipartite_distribution1() const {
  return _internal_has_bipartite_distribution1();
}
inline void ReadEdges::clear_bipartite_distribution1() {
  if (bipartite_distribution1_ != nullptr) bipartite_distribution1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::NormalDistribution& ReadEdges::_internal_bipartite_distribution1() const {
  const ::ml_metadata::NormalDistribution* p = bipartite_distribution1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::NormalDistribution*>(
      &::ml_metadata::_NormalDistribution_default_instance_);
}
inline const ::ml_metadata::NormalDistribution& ReadEdges::bipartite_distribution1() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ReadEdges.bipartite_distribution1)
  return _internal_bipartite_distribution1();
}
inline void ReadEdges::unsafe_arena_set_allocated_bipartite_distribution1(
    ::ml_metadata::NormalDistribution* bipartite_distribution1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bipartite_distribution1_);
  }
  bipartite_distribution1_ = bipartite_distribution1;
  if (bipartite_distribution1) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ReadEdges.bipartite_distribution1)
}
inline ::ml_metadata::NormalDistribution* ReadEdges::release_bipartite_distribution1() {
  auto temp = unsafe_arena_release_bipartite_distribution1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::NormalDistribution* ReadEdges::unsafe_arena_release_bipartite_distribution1() {
  // @@protoc_insertion_point(field_release:ml_metadata.ReadEdges.bipartite_distribution1)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::NormalDistribution* temp = bipartite_distribution1_;
  bipartite_distribution1_ = nullptr;
  return temp;
}
inline ::ml_metadata::NormalDistribution* ReadEdges::_internal_mutable_bipartite_distribution1() {
  _has_bits_[0] |= 0x00000001u;
  if (bipartite_distribution1_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::NormalDistribution>(GetArena());
    bipartite_distribution1_ = p;
  }
  return bipartite_distribution1_;
}
inline ::ml_metadata::NormalDistribution* ReadEdges::mutable_bipartite_distribution1() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.ReadEdges.bipartite_distribution1)
  return _internal_mutable_bipartite_distribution1();
}
inline void ReadEdges::set_allocated_bipartite_distribution1(::ml_metadata::NormalDistribution* bipartite_distribution1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bipartite_distribution1_;
  }
  if (bipartite_distribution1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bipartite_distribution1);
    if (message_arena != submessage_arena) {
      bipartite_distribution1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bipartite_distribution1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bipartite_distribution1_ = bipartite_distribution1;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ReadEdges.bipartite_distribution1)
}

// optional .ml_metadata.NormalDistribution bipartite_distribution2 = 2;
inline bool ReadEdges::_internal_has_bipartite_distribution2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || bipartite_distribution2_ != nullptr);
  return value;
}
inline bool ReadEdges::has_bipartite_distribution2() const {
  return _internal_has_bipartite_distribution2();
}
inline void ReadEdges::clear_bipartite_distribution2() {
  if (bipartite_distribution2_ != nullptr) bipartite_distribution2_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ml_metadata::NormalDistribution& ReadEdges::_internal_bipartite_distribution2() const {
  const ::ml_metadata::NormalDistribution* p = bipartite_distribution2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::NormalDistribution*>(
      &::ml_metadata::_NormalDistribution_default_instance_);
}
inline const ::ml_metadata::NormalDistribution& ReadEdges::bipartite_distribution2() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ReadEdges.bipartite_distribution2)
  return _internal_bipartite_distribution2();
}
inline void ReadEdges::unsafe_arena_set_allocated_bipartite_distribution2(
    ::ml_metadata::NormalDistribution* bipartite_distribution2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bipartite_distribution2_);
  }
  bipartite_distribution2_ = bipartite_distribution2;
  if (bipartite_distribution2) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.ReadEdges.bipartite_distribution2)
}
inline ::ml_metadata::NormalDistribution* ReadEdges::release_bipartite_distribution2() {
  auto temp = unsafe_arena_release_bipartite_distribution2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::NormalDistribution* ReadEdges::unsafe_arena_release_bipartite_distribution2() {
  // @@protoc_insertion_point(field_release:ml_metadata.ReadEdges.bipartite_distribution2)
  _has_bits_[0] &= ~0x00000002u;
  ::ml_metadata::NormalDistribution* temp = bipartite_distribution2_;
  bipartite_distribution2_ = nullptr;
  return temp;
}
inline ::ml_metadata::NormalDistribution* ReadEdges::_internal_mutable_bipartite_distribution2() {
  _has_bits_[0] |= 0x00000002u;
  if (bipartite_distribution2_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::NormalDistribution>(GetArena());
    bipartite_distribution2_ = p;
  }
  return bipartite_distribution2_;
}
inline ::ml_metadata::NormalDistribution* ReadEdges::mutable_bipartite_distribution2() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.ReadEdges.bipartite_distribution2)
  return _internal_mutable_bipartite_distribution2();
}
inline void ReadEdges::set_allocated_bipartite_distribution2(::ml_metadata::NormalDistribution* bipartite_distribution2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bipartite_distribution2_;
  }
  if (bipartite_distribution2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bipartite_distribution2);
    if (message_arena != submessage_arena) {
      bipartite_distribution2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bipartite_distribution2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bipartite_distribution2_ = bipartite_distribution2;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.ReadEdges.bipartite_distribution2)
}

// -------------------------------------------------------------------

// Workload

// .ml_metadata.InitStore init_store = 1;
inline bool Workload::_internal_has_init_store() const {
  return workloads_case() == kInitStore;
}
inline bool Workload::has_init_store() const {
  return _internal_has_init_store();
}
inline void Workload::set_has_init_store() {
  _oneof_case_[0] = kInitStore;
}
inline void Workload::clear_init_store() {
  if (_internal_has_init_store()) {
    if (GetArena() == nullptr) {
      delete workloads_.init_store_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::InitStore* Workload::release_init_store() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.init_store)
  if (_internal_has_init_store()) {
    clear_has_workloads();
      ::ml_metadata::InitStore* temp = workloads_.init_store_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.init_store_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::InitStore& Workload::_internal_init_store() const {
  return _internal_has_init_store()
      ? *workloads_.init_store_
      : *reinterpret_cast< ::ml_metadata::InitStore*>(&::ml_metadata::_InitStore_default_instance_);
}
inline const ::ml_metadata::InitStore& Workload::init_store() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.init_store)
  return _internal_init_store();
}
inline ::ml_metadata::InitStore* Workload::unsafe_arena_release_init_store() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.init_store)
  if (_internal_has_init_store()) {
    clear_has_workloads();
    ::ml_metadata::InitStore* temp = workloads_.init_store_;
    workloads_.init_store_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_init_store(::ml_metadata::InitStore* init_store) {
  clear_workloads();
  if (init_store) {
    set_has_init_store();
    workloads_.init_store_ = init_store;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.init_store)
}
inline ::ml_metadata::InitStore* Workload::_internal_mutable_init_store() {
  if (!_internal_has_init_store()) {
    clear_workloads();
    set_has_init_store();
    workloads_.init_store_ = CreateMaybeMessage< ::ml_metadata::InitStore >(GetArena());
  }
  return workloads_.init_store_;
}
inline ::ml_metadata::InitStore* Workload::mutable_init_store() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.init_store)
  return _internal_mutable_init_store();
}

// .ml_metadata.FillTypes fill_types = 2;
inline bool Workload::_internal_has_fill_types() const {
  return workloads_case() == kFillTypes;
}
inline bool Workload::has_fill_types() const {
  return _internal_has_fill_types();
}
inline void Workload::set_has_fill_types() {
  _oneof_case_[0] = kFillTypes;
}
inline void Workload::clear_fill_types() {
  if (_internal_has_fill_types()) {
    if (GetArena() == nullptr) {
      delete workloads_.fill_types_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::FillTypes* Workload::release_fill_types() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.fill_types)
  if (_internal_has_fill_types()) {
    clear_has_workloads();
      ::ml_metadata::FillTypes* temp = workloads_.fill_types_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.fill_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::FillTypes& Workload::_internal_fill_types() const {
  return _internal_has_fill_types()
      ? *workloads_.fill_types_
      : *reinterpret_cast< ::ml_metadata::FillTypes*>(&::ml_metadata::_FillTypes_default_instance_);
}
inline const ::ml_metadata::FillTypes& Workload::fill_types() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.fill_types)
  return _internal_fill_types();
}
inline ::ml_metadata::FillTypes* Workload::unsafe_arena_release_fill_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.fill_types)
  if (_internal_has_fill_types()) {
    clear_has_workloads();
    ::ml_metadata::FillTypes* temp = workloads_.fill_types_;
    workloads_.fill_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_fill_types(::ml_metadata::FillTypes* fill_types) {
  clear_workloads();
  if (fill_types) {
    set_has_fill_types();
    workloads_.fill_types_ = fill_types;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.fill_types)
}
inline ::ml_metadata::FillTypes* Workload::_internal_mutable_fill_types() {
  if (!_internal_has_fill_types()) {
    clear_workloads();
    set_has_fill_types();
    workloads_.fill_types_ = CreateMaybeMessage< ::ml_metadata::FillTypes >(GetArena());
  }
  return workloads_.fill_types_;
}
inline ::ml_metadata::FillTypes* Workload::mutable_fill_types() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.fill_types)
  return _internal_mutable_fill_types();
}

// .ml_metadata.FillNodes fill_nodes = 3;
inline bool Workload::_internal_has_fill_nodes() const {
  return workloads_case() == kFillNodes;
}
inline bool Workload::has_fill_nodes() const {
  return _internal_has_fill_nodes();
}
inline void Workload::set_has_fill_nodes() {
  _oneof_case_[0] = kFillNodes;
}
inline void Workload::clear_fill_nodes() {
  if (_internal_has_fill_nodes()) {
    if (GetArena() == nullptr) {
      delete workloads_.fill_nodes_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::FillNodes* Workload::release_fill_nodes() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.fill_nodes)
  if (_internal_has_fill_nodes()) {
    clear_has_workloads();
      ::ml_metadata::FillNodes* temp = workloads_.fill_nodes_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.fill_nodes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::FillNodes& Workload::_internal_fill_nodes() const {
  return _internal_has_fill_nodes()
      ? *workloads_.fill_nodes_
      : *reinterpret_cast< ::ml_metadata::FillNodes*>(&::ml_metadata::_FillNodes_default_instance_);
}
inline const ::ml_metadata::FillNodes& Workload::fill_nodes() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.fill_nodes)
  return _internal_fill_nodes();
}
inline ::ml_metadata::FillNodes* Workload::unsafe_arena_release_fill_nodes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.fill_nodes)
  if (_internal_has_fill_nodes()) {
    clear_has_workloads();
    ::ml_metadata::FillNodes* temp = workloads_.fill_nodes_;
    workloads_.fill_nodes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_fill_nodes(::ml_metadata::FillNodes* fill_nodes) {
  clear_workloads();
  if (fill_nodes) {
    set_has_fill_nodes();
    workloads_.fill_nodes_ = fill_nodes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.fill_nodes)
}
inline ::ml_metadata::FillNodes* Workload::_internal_mutable_fill_nodes() {
  if (!_internal_has_fill_nodes()) {
    clear_workloads();
    set_has_fill_nodes();
    workloads_.fill_nodes_ = CreateMaybeMessage< ::ml_metadata::FillNodes >(GetArena());
  }
  return workloads_.fill_nodes_;
}
inline ::ml_metadata::FillNodes* Workload::mutable_fill_nodes() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.fill_nodes)
  return _internal_mutable_fill_nodes();
}

// .ml_metadata.FillEdges fill_edges = 4;
inline bool Workload::_internal_has_fill_edges() const {
  return workloads_case() == kFillEdges;
}
inline bool Workload::has_fill_edges() const {
  return _internal_has_fill_edges();
}
inline void Workload::set_has_fill_edges() {
  _oneof_case_[0] = kFillEdges;
}
inline void Workload::clear_fill_edges() {
  if (_internal_has_fill_edges()) {
    if (GetArena() == nullptr) {
      delete workloads_.fill_edges_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::FillEdges* Workload::release_fill_edges() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.fill_edges)
  if (_internal_has_fill_edges()) {
    clear_has_workloads();
      ::ml_metadata::FillEdges* temp = workloads_.fill_edges_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.fill_edges_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::FillEdges& Workload::_internal_fill_edges() const {
  return _internal_has_fill_edges()
      ? *workloads_.fill_edges_
      : *reinterpret_cast< ::ml_metadata::FillEdges*>(&::ml_metadata::_FillEdges_default_instance_);
}
inline const ::ml_metadata::FillEdges& Workload::fill_edges() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.fill_edges)
  return _internal_fill_edges();
}
inline ::ml_metadata::FillEdges* Workload::unsafe_arena_release_fill_edges() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.fill_edges)
  if (_internal_has_fill_edges()) {
    clear_has_workloads();
    ::ml_metadata::FillEdges* temp = workloads_.fill_edges_;
    workloads_.fill_edges_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_fill_edges(::ml_metadata::FillEdges* fill_edges) {
  clear_workloads();
  if (fill_edges) {
    set_has_fill_edges();
    workloads_.fill_edges_ = fill_edges;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.fill_edges)
}
inline ::ml_metadata::FillEdges* Workload::_internal_mutable_fill_edges() {
  if (!_internal_has_fill_edges()) {
    clear_workloads();
    set_has_fill_edges();
    workloads_.fill_edges_ = CreateMaybeMessage< ::ml_metadata::FillEdges >(GetArena());
  }
  return workloads_.fill_edges_;
}
inline ::ml_metadata::FillEdges* Workload::mutable_fill_edges() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.fill_edges)
  return _internal_mutable_fill_edges();
}

// .ml_metadata.ReadTypes read_types = 5;
inline bool Workload::_internal_has_read_types() const {
  return workloads_case() == kReadTypes;
}
inline bool Workload::has_read_types() const {
  return _internal_has_read_types();
}
inline void Workload::set_has_read_types() {
  _oneof_case_[0] = kReadTypes;
}
inline void Workload::clear_read_types() {
  if (_internal_has_read_types()) {
    if (GetArena() == nullptr) {
      delete workloads_.read_types_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::ReadTypes* Workload::release_read_types() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.read_types)
  if (_internal_has_read_types()) {
    clear_has_workloads();
      ::ml_metadata::ReadTypes* temp = workloads_.read_types_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.read_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::ReadTypes& Workload::_internal_read_types() const {
  return _internal_has_read_types()
      ? *workloads_.read_types_
      : *reinterpret_cast< ::ml_metadata::ReadTypes*>(&::ml_metadata::_ReadTypes_default_instance_);
}
inline const ::ml_metadata::ReadTypes& Workload::read_types() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.read_types)
  return _internal_read_types();
}
inline ::ml_metadata::ReadTypes* Workload::unsafe_arena_release_read_types() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.read_types)
  if (_internal_has_read_types()) {
    clear_has_workloads();
    ::ml_metadata::ReadTypes* temp = workloads_.read_types_;
    workloads_.read_types_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_read_types(::ml_metadata::ReadTypes* read_types) {
  clear_workloads();
  if (read_types) {
    set_has_read_types();
    workloads_.read_types_ = read_types;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.read_types)
}
inline ::ml_metadata::ReadTypes* Workload::_internal_mutable_read_types() {
  if (!_internal_has_read_types()) {
    clear_workloads();
    set_has_read_types();
    workloads_.read_types_ = CreateMaybeMessage< ::ml_metadata::ReadTypes >(GetArena());
  }
  return workloads_.read_types_;
}
inline ::ml_metadata::ReadTypes* Workload::mutable_read_types() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.read_types)
  return _internal_mutable_read_types();
}

// .ml_metadata.ReadNodes read_nodes = 6;
inline bool Workload::_internal_has_read_nodes() const {
  return workloads_case() == kReadNodes;
}
inline bool Workload::has_read_nodes() const {
  return _internal_has_read_nodes();
}
inline void Workload::set_has_read_nodes() {
  _oneof_case_[0] = kReadNodes;
}
inline void Workload::clear_read_nodes() {
  if (_internal_has_read_nodes()) {
    if (GetArena() == nullptr) {
      delete workloads_.read_nodes_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::ReadNodes* Workload::release_read_nodes() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.read_nodes)
  if (_internal_has_read_nodes()) {
    clear_has_workloads();
      ::ml_metadata::ReadNodes* temp = workloads_.read_nodes_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.read_nodes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::ReadNodes& Workload::_internal_read_nodes() const {
  return _internal_has_read_nodes()
      ? *workloads_.read_nodes_
      : *reinterpret_cast< ::ml_metadata::ReadNodes*>(&::ml_metadata::_ReadNodes_default_instance_);
}
inline const ::ml_metadata::ReadNodes& Workload::read_nodes() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.read_nodes)
  return _internal_read_nodes();
}
inline ::ml_metadata::ReadNodes* Workload::unsafe_arena_release_read_nodes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.read_nodes)
  if (_internal_has_read_nodes()) {
    clear_has_workloads();
    ::ml_metadata::ReadNodes* temp = workloads_.read_nodes_;
    workloads_.read_nodes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_read_nodes(::ml_metadata::ReadNodes* read_nodes) {
  clear_workloads();
  if (read_nodes) {
    set_has_read_nodes();
    workloads_.read_nodes_ = read_nodes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.read_nodes)
}
inline ::ml_metadata::ReadNodes* Workload::_internal_mutable_read_nodes() {
  if (!_internal_has_read_nodes()) {
    clear_workloads();
    set_has_read_nodes();
    workloads_.read_nodes_ = CreateMaybeMessage< ::ml_metadata::ReadNodes >(GetArena());
  }
  return workloads_.read_nodes_;
}
inline ::ml_metadata::ReadNodes* Workload::mutable_read_nodes() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.read_nodes)
  return _internal_mutable_read_nodes();
}

// .ml_metadata.ReadEdges read_edges = 7;
inline bool Workload::_internal_has_read_edges() const {
  return workloads_case() == kReadEdges;
}
inline bool Workload::has_read_edges() const {
  return _internal_has_read_edges();
}
inline void Workload::set_has_read_edges() {
  _oneof_case_[0] = kReadEdges;
}
inline void Workload::clear_read_edges() {
  if (_internal_has_read_edges()) {
    if (GetArena() == nullptr) {
      delete workloads_.read_edges_;
    }
    clear_has_workloads();
  }
}
inline ::ml_metadata::ReadEdges* Workload::release_read_edges() {
  // @@protoc_insertion_point(field_release:ml_metadata.Workload.read_edges)
  if (_internal_has_read_edges()) {
    clear_has_workloads();
      ::ml_metadata::ReadEdges* temp = workloads_.read_edges_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    workloads_.read_edges_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ml_metadata::ReadEdges& Workload::_internal_read_edges() const {
  return _internal_has_read_edges()
      ? *workloads_.read_edges_
      : *reinterpret_cast< ::ml_metadata::ReadEdges*>(&::ml_metadata::_ReadEdges_default_instance_);
}
inline const ::ml_metadata::ReadEdges& Workload::read_edges() const {
  // @@protoc_insertion_point(field_get:ml_metadata.Workload.read_edges)
  return _internal_read_edges();
}
inline ::ml_metadata::ReadEdges* Workload::unsafe_arena_release_read_edges() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ml_metadata.Workload.read_edges)
  if (_internal_has_read_edges()) {
    clear_has_workloads();
    ::ml_metadata::ReadEdges* temp = workloads_.read_edges_;
    workloads_.read_edges_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Workload::unsafe_arena_set_allocated_read_edges(::ml_metadata::ReadEdges* read_edges) {
  clear_workloads();
  if (read_edges) {
    set_has_read_edges();
    workloads_.read_edges_ = read_edges;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.Workload.read_edges)
}
inline ::ml_metadata::ReadEdges* Workload::_internal_mutable_read_edges() {
  if (!_internal_has_read_edges()) {
    clear_workloads();
    set_has_read_edges();
    workloads_.read_edges_ = CreateMaybeMessage< ::ml_metadata::ReadEdges >(GetArena());
  }
  return workloads_.read_edges_;
}
inline ::ml_metadata::ReadEdges* Workload::mutable_read_edges() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.Workload.read_edges)
  return _internal_mutable_read_edges();
}

inline bool Workload::has_workloads() const {
  return workloads_case() != WORKLOADS_NOT_SET;
}
inline void Workload::clear_has_workloads() {
  _oneof_case_[0] = WORKLOADS_NOT_SET;
}
inline Workload::WorkloadsCase Workload::workloads_case() const {
  return Workload::WorkloadsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ThreadEnv

// optional int32 thread_num = 1;
inline bool ThreadEnv::_internal_has_thread_num() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ThreadEnv::has_thread_num() const {
  return _internal_has_thread_num();
}
inline void ThreadEnv::clear_thread_num() {
  thread_num_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ThreadEnv::_internal_thread_num() const {
  return thread_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ThreadEnv::thread_num() const {
  // @@protoc_insertion_point(field_get:ml_metadata.ThreadEnv.thread_num)
  return _internal_thread_num();
}
inline void ThreadEnv::_internal_set_thread_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  thread_num_ = value;
}
inline void ThreadEnv::set_thread_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_thread_num(value);
  // @@protoc_insertion_point(field_set:ml_metadata.ThreadEnv.thread_num)
}

// -------------------------------------------------------------------

// MLMDBenchReport

// repeated .ml_metadata.WorkloadResult summaries = 1;
inline int MLMDBenchReport::_internal_summaries_size() const {
  return summaries_.size();
}
inline int MLMDBenchReport::summaries_size() const {
  return _internal_summaries_size();
}
inline void MLMDBenchReport::clear_summaries() {
  summaries_.Clear();
}
inline ::ml_metadata::WorkloadResult* MLMDBenchReport::mutable_summaries(int index) {
  // @@protoc_insertion_point(field_mutable:ml_metadata.MLMDBenchReport.summaries)
  return summaries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::WorkloadResult >*
MLMDBenchReport::mutable_summaries() {
  // @@protoc_insertion_point(field_mutable_list:ml_metadata.MLMDBenchReport.summaries)
  return &summaries_;
}
inline const ::ml_metadata::WorkloadResult& MLMDBenchReport::_internal_summaries(int index) const {
  return summaries_.Get(index);
}
inline const ::ml_metadata::WorkloadResult& MLMDBenchReport::summaries(int index) const {
  // @@protoc_insertion_point(field_get:ml_metadata.MLMDBenchReport.summaries)
  return _internal_summaries(index);
}
inline ::ml_metadata::WorkloadResult* MLMDBenchReport::_internal_add_summaries() {
  return summaries_.Add();
}
inline ::ml_metadata::WorkloadResult* MLMDBenchReport::add_summaries() {
  // @@protoc_insertion_point(field_add:ml_metadata.MLMDBenchReport.summaries)
  return _internal_add_summaries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ml_metadata::WorkloadResult >&
MLMDBenchReport::summaries() const {
  // @@protoc_insertion_point(field_list:ml_metadata.MLMDBenchReport.summaries)
  return summaries_;
}

// -------------------------------------------------------------------

// WorkloadResult

// optional .ml_metadata.Workload workload = 1;
inline bool WorkloadResult::_internal_has_workload() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || workload_ != nullptr);
  return value;
}
inline bool WorkloadResult::has_workload() const {
  return _internal_has_workload();
}
inline void WorkloadResult::clear_workload() {
  if (workload_ != nullptr) workload_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ml_metadata::Workload& WorkloadResult::_internal_workload() const {
  const ::ml_metadata::Workload* p = workload_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ml_metadata::Workload*>(
      &::ml_metadata::_Workload_default_instance_);
}
inline const ::ml_metadata::Workload& WorkloadResult::workload() const {
  // @@protoc_insertion_point(field_get:ml_metadata.WorkloadResult.workload)
  return _internal_workload();
}
inline void WorkloadResult::unsafe_arena_set_allocated_workload(
    ::ml_metadata::Workload* workload) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(workload_);
  }
  workload_ = workload;
  if (workload) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ml_metadata.WorkloadResult.workload)
}
inline ::ml_metadata::Workload* WorkloadResult::release_workload() {
  auto temp = unsafe_arena_release_workload();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ml_metadata::Workload* WorkloadResult::unsafe_arena_release_workload() {
  // @@protoc_insertion_point(field_release:ml_metadata.WorkloadResult.workload)
  _has_bits_[0] &= ~0x00000001u;
  ::ml_metadata::Workload* temp = workload_;
  workload_ = nullptr;
  return temp;
}
inline ::ml_metadata::Workload* WorkloadResult::_internal_mutable_workload() {
  _has_bits_[0] |= 0x00000001u;
  if (workload_ == nullptr) {
    auto* p = CreateMaybeMessage<::ml_metadata::Workload>(GetArena());
    workload_ = p;
  }
  return workload_;
}
inline ::ml_metadata::Workload* WorkloadResult::mutable_workload() {
  // @@protoc_insertion_point(field_mutable:ml_metadata.WorkloadResult.workload)
  return _internal_mutable_workload();
}
inline void WorkloadResult::set_allocated_workload(::ml_metadata::Workload* workload) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete workload_;
  }
  if (workload) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(workload);
    if (message_arena != submessage_arena) {
      workload = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, workload, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  workload_ = workload;
  // @@protoc_insertion_point(field_set_allocated:ml_metadata.WorkloadResult.workload)
}

// optional double microsecond_per_op = 2;
inline bool WorkloadResult::_internal_has_microsecond_per_op() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WorkloadResult::has_microsecond_per_op() const {
  return _internal_has_microsecond_per_op();
}
inline void WorkloadResult::clear_microsecond_per_op() {
  microsecond_per_op_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double WorkloadResult::_internal_microsecond_per_op() const {
  return microsecond_per_op_;
}
inline double WorkloadResult::microsecond_per_op() const {
  // @@protoc_insertion_point(field_get:ml_metadata.WorkloadResult.microsecond_per_op)
  return _internal_microsecond_per_op();
}
inline void WorkloadResult::_internal_set_microsecond_per_op(double value) {
  _has_bits_[0] |= 0x00000002u;
  microsecond_per_op_ = value;
}
inline void WorkloadResult::set_microsecond_per_op(double value) {
  _internal_set_microsecond_per_op(value);
  // @@protoc_insertion_point(field_set:ml_metadata.WorkloadResult.microsecond_per_op)
}

// optional double bytes_per_second = 3;
inline bool WorkloadResult::_internal_has_bytes_per_second() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WorkloadResult::has_bytes_per_second() const {
  return _internal_has_bytes_per_second();
}
inline void WorkloadResult::clear_bytes_per_second() {
  bytes_per_second_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double WorkloadResult::_internal_bytes_per_second() const {
  return bytes_per_second_;
}
inline double WorkloadResult::bytes_per_second() const {
  // @@protoc_insertion_point(field_get:ml_metadata.WorkloadResult.bytes_per_second)
  return _internal_bytes_per_second();
}
inline void WorkloadResult::_internal_set_bytes_per_second(double value) {
  _has_bits_[0] |= 0x00000004u;
  bytes_per_second_ = value;
}
inline void WorkloadResult::set_bytes_per_second(double value) {
  _internal_set_bytes_per_second(value);
  // @@protoc_insertion_point(field_set:ml_metadata.WorkloadResult.bytes_per_second)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ml_metadata

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ml_metadata::FillTypes_specification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::FillTypes_specification>() {
  return ::ml_metadata::FillTypes_specification_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::FillNodes_specification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::FillNodes_specification>() {
  return ::ml_metadata::FillNodes_specification_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::FillEdges_specification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::FillEdges_specification>() {
  return ::ml_metadata::FillEdges_specification_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ReadTypes_specification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ReadTypes_specification>() {
  return ::ml_metadata::ReadTypes_specification_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ReadNodes_specification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ReadNodes_specification>() {
  return ::ml_metadata::ReadNodes_specification_descriptor();
}
template <> struct is_proto_enum< ::ml_metadata::ReadEdges_specification> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ml_metadata::ReadEdges_specification>() {
  return ::ml_metadata::ReadEdges_specification_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_metadata_5fbench_2eproto
